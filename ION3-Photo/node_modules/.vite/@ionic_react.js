import {
  mdTransitionAnimation
} from "./chunk-CJQR6B66.js";
import {
  iosTransitionAnimation
} from "./chunk-XX3VWBXN.js";
import {
  CSS,
  bootstrapLazy,
  componentOnReady,
  createAnimation,
  getMode,
  plt,
  promiseResolve,
  setMode,
  win
} from "./chunk-7MGZ63NN.js";
import {
  require_react_dom
} from "./chunk-7X5Y57ZA.js";
import {
  require_react
} from "./chunk-4CGWSFIL.js";
import {
  __awaiter,
  __generator,
  __rest
} from "./chunk-CX6VZJLV.js";
import {
  __toModule,
  define_process_env_default,
  init_define_process_env
} from "./chunk-JD4GRHLE.js";

// dep:@ionic_react
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/react/dist/index.esm.js
init_define_process_env();
var import_react = __toModule(require_react());

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/loader/index.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm/polyfills/index.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/loader.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/app-globals-fd807b9a.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/ionic-global-63a97a32.js
init_define_process_env();
var getPlatforms = function(t) {
  return setupPlatforms(t);
};
var isPlatform = function(t, e) {
  if (typeof t === "string") {
    e = t;
    t = void 0;
  }
  return getPlatforms(t).includes(e);
};
var setupPlatforms = function(t) {
  if (t === void 0) {
    t = window;
  }
  if (typeof t === "undefined") {
    return [];
  }
  t.Ionic = t.Ionic || {};
  var e = t.Ionic.platforms;
  if (e == null) {
    e = t.Ionic.platforms = detectPlatforms(t);
    e.forEach(function(e2) {
      return t.document.documentElement.classList.add("plt-" + e2);
    });
  }
  return e;
};
var detectPlatforms = function(t) {
  return Object.keys(PLATFORMS_MAP).filter(function(e) {
    return PLATFORMS_MAP[e](t);
  });
};
var isMobileWeb = function(t) {
  return isMobile(t) && !isHybrid(t);
};
var isIpad = function(t) {
  if (testUserAgent(t, /iPad/i)) {
    return true;
  }
  if (testUserAgent(t, /Macintosh/i) && isMobile(t)) {
    return true;
  }
  return false;
};
var isIphone = function(t) {
  return testUserAgent(t, /iPhone/i);
};
var isIOS = function(t) {
  return testUserAgent(t, /iPhone|iPod/i) || isIpad(t);
};
var isAndroid = function(t) {
  return testUserAgent(t, /android|sink/i);
};
var isAndroidTablet = function(t) {
  return isAndroid(t) && !testUserAgent(t, /mobile/i);
};
var isPhablet = function(t) {
  var e = t.innerWidth;
  var n = t.innerHeight;
  var i = Math.min(e, n);
  var r = Math.max(e, n);
  return i > 390 && i < 520 && (r > 620 && r < 800);
};
var isTablet = function(t) {
  var e = t.innerWidth;
  var n = t.innerHeight;
  var i = Math.min(e, n);
  var r = Math.max(e, n);
  return isIpad(t) || isAndroidTablet(t) || i > 460 && i < 820 && (r > 780 && r < 1400);
};
var isMobile = function(t) {
  return matchMedia(t, "(any-pointer:coarse)");
};
var isDesktop = function(t) {
  return !isMobile(t);
};
var isHybrid = function(t) {
  return isCordova(t) || isCapacitorNative(t);
};
var isCordova = function(t) {
  return !!(t["cordova"] || t["phonegap"] || t["PhoneGap"]);
};
var isCapacitorNative = function(t) {
  var e = t["Capacitor"];
  return !!(e && e.isNative);
};
var isElectron = function(t) {
  return testUserAgent(t, /electron/i);
};
var isPWA = function(t) {
  return !!(t.matchMedia("(display-mode: standalone)").matches || t.navigator.standalone);
};
var testUserAgent = function(t, e) {
  return e.test(t.navigator.userAgent);
};
var matchMedia = function(t, e) {
  return t.matchMedia(e).matches;
};
var PLATFORMS_MAP = { ipad: isIpad, iphone: isIphone, ios: isIOS, android: isAndroid, phablet: isPhablet, tablet: isTablet, cordova: isCordova, capacitor: isCapacitorNative, electron: isElectron, pwa: isPWA, mobile: isMobile, mobileweb: isMobileWeb, desktop: isDesktop, hybrid: isHybrid };
var Config = function() {
  function t() {
    this.m = new Map();
  }
  t.prototype.reset = function(t2) {
    this.m = new Map(Object.entries(t2));
  };
  t.prototype.get = function(t2, e) {
    var n = this.m.get(t2);
    return n !== void 0 ? n : e;
  };
  t.prototype.getBoolean = function(t2, e) {
    if (e === void 0) {
      e = false;
    }
    var n = this.m.get(t2);
    if (n === void 0) {
      return e;
    }
    if (typeof n === "string") {
      return n === "true";
    }
    return !!n;
  };
  t.prototype.getNumber = function(t2, e) {
    var n = parseFloat(this.m.get(t2));
    return isNaN(n) ? e !== void 0 ? e : NaN : n;
  };
  t.prototype.set = function(t2, e) {
    this.m.set(t2, e);
  };
  return t;
}();
var config = new Config();
var configFromSession = function(t) {
  try {
    var e = t.sessionStorage.getItem(IONIC_SESSION_KEY);
    return e !== null ? JSON.parse(e) : {};
  } catch (n) {
    return {};
  }
};
var saveConfig = function(t, e) {
  try {
    t.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(e));
  } catch (n) {
    return;
  }
};
var configFromURL = function(t) {
  var e = {};
  t.location.search.slice(1).split("&").map(function(t2) {
    return t2.split("=");
  }).map(function(t2) {
    var e2 = t2[0], n = t2[1];
    return [decodeURIComponent(e2), decodeURIComponent(n)];
  }).filter(function(t2) {
    var e2 = t2[0];
    return startsWith(e2, IONIC_PREFIX);
  }).map(function(t2) {
    var e2 = t2[0], n = t2[1];
    return [e2.slice(IONIC_PREFIX.length), n];
  }).forEach(function(t2) {
    var n = t2[0], i = t2[1];
    e[n] = i;
  });
  return e;
};
var startsWith = function(t, e) {
  return t.substr(0, e.length) === e;
};
var IONIC_PREFIX = "ionic:";
var IONIC_SESSION_KEY = "ionic-persist-config";
var defaultMode;
var getIonMode = function(t) {
  return t && getMode(t) || defaultMode;
};
var initialize = function(t) {
  if (t === void 0) {
    t = {};
  }
  if (typeof window === "undefined") {
    return;
  }
  var e = window.document;
  var n = window;
  var i = n.Ionic = n.Ionic || {};
  setupPlatforms(n);
  var r = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(n)), { persistConfig: false }), i.config), configFromURL(n)), t);
  config.reset(r);
  if (config.getBoolean("persistConfig")) {
    saveConfig(n, r);
  }
  i.config = config;
  i.mode = defaultMode = config.get("mode", e.documentElement.getAttribute("mode") || (isPlatform(n, "ios") ? "ios" : "md"));
  config.set("mode", defaultMode);
  e.documentElement.setAttribute("mode", defaultMode);
  e.documentElement.classList.add(defaultMode);
  if (config.getBoolean("_testing")) {
    config.set("animated", false);
  }
  var o = function(t2) {
    return t2.tagName && t2.tagName.startsWith("ION-");
  };
  var a = function(t2) {
    return ["ios", "md"].includes(t2);
  };
  setMode(function(t2) {
    while (t2) {
      var e2 = t2.mode || t2.getAttribute("mode");
      if (e2) {
        if (a(e2)) {
          return e2;
        } else if (o(t2)) {
          console.warn('Invalid ionic mode: "' + e2 + '", expected: "ios" or "md"');
        }
      }
      t2 = t2.parentElement;
    }
    return defaultMode;
  });
};

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/app-globals-fd807b9a.js
var globalScripts = initialize;

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/loader.js
var patchEsm = function() {
  if (!(CSS && CSS.supports && CSS.supports("color", "var(--c)"))) {
    return import("./css-shim-2ccf4dec-LK5JB5VQ.js").then(function() {
      if (plt.$cssShim$ = win.__cssshim) {
        return plt.$cssShim$.i();
      } else {
        return 0;
      }
    });
  }
  return promiseResolve();
};
var defineCustomElements = function(e, o) {
  if (typeof window === "undefined")
    return Promise.resolve();
  return patchEsm().then(function() {
    globalScripts();
    return bootstrapLazy(JSON.parse('[["ion-select_3",[[2,"ion-select-popover",{"header":[1],"subHeader":[1,"sub-header"],"message":[1],"options":[16]},[[0,"ionChange","onSelect"]]],[33,"ion-select",{"disabled":[4],"cancelText":[1,"cancel-text"],"okText":[1,"ok-text"],"placeholder":[1],"name":[1],"selectedText":[1,"selected-text"],"multiple":[4],"interface":[1],"interfaceOptions":[8,"interface-options"],"compareWith":[1,"compare-with"],"value":[1032],"isExpanded":[32],"open":[64]}],[1,"ion-select-option",{"disabled":[4],"value":[8]}]]],["ion-menu_3",[[33,"ion-menu-button",{"color":[513],"disabled":[4],"menu":[1],"autoHide":[4,"auto-hide"],"type":[1],"visible":[32]},[[16,"ionMenuChange","visibilityChanged"],[16,"ionSplitPaneVisible","visibilityChanged"]]],[33,"ion-menu",{"contentId":[513,"content-id"],"menuId":[513,"menu-id"],"type":[1025],"disabled":[1028],"side":[513],"swipeGesture":[4,"swipe-gesture"],"maxEdgeStart":[2,"max-edge-start"],"isPaneVisible":[32],"isEndSide":[32],"isOpen":[64],"isActive":[64],"open":[64],"close":[64],"toggle":[64],"setOpen":[64]},[[16,"ionSplitPaneVisible","onSplitPaneChanged"],[2,"click","onBackdropClick"]]],[1,"ion-menu-toggle",{"menu":[1],"autoHide":[4,"auto-hide"],"visible":[32]},[[16,"ionMenuChange","visibilityChanged"],[16,"ionSplitPaneVisible","visibilityChanged"]]]]],["ion-action-sheet",[[34,"ion-action-sheet",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"buttons":[16],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"header":[1],"subHeader":[1,"sub-header"],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-fab_3",[[33,"ion-fab-button",{"color":[513],"activated":[4],"disabled":[4],"download":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1],"show":[4],"translucent":[4],"type":[1],"size":[1],"closeIcon":[1,"close-icon"]}],[1,"ion-fab",{"horizontal":[1],"vertical":[1],"edge":[4],"activated":[1028],"close":[64]}],[1,"ion-fab-list",{"activated":[4],"side":[1]}]]],["ion-refresher_2",[[0,"ion-refresher-content",{"pullingIcon":[1025,"pulling-icon"],"pullingText":[1,"pulling-text"],"refreshingSpinner":[1025,"refreshing-spinner"],"refreshingText":[1,"refreshing-text"]}],[32,"ion-refresher",{"pullMin":[2,"pull-min"],"pullMax":[2,"pull-max"],"closeDuration":[1,"close-duration"],"snapbackDuration":[1,"snapback-duration"],"pullFactor":[2,"pull-factor"],"disabled":[4],"nativeRefresher":[32],"state":[32],"complete":[64],"cancel":[64],"getProgress":[64]}]]],["ion-alert",[[34,"ion-alert",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"cssClass":[1,"css-class"],"header":[1],"subHeader":[1,"sub-header"],"message":[1],"buttons":[16],"inputs":[1040],"backdropDismiss":[4,"backdrop-dismiss"],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]},[[4,"keydown","onKeydown"]]]]],["ion-back-button",[[33,"ion-back-button",{"color":[513],"defaultHref":[1025,"default-href"],"disabled":[516],"icon":[1],"text":[1],"type":[1],"routerAnimation":[16]}]]],["ion-loading",[[34,"ion-loading",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"message":[1],"cssClass":[1,"css-class"],"duration":[2],"backdropDismiss":[4,"backdrop-dismiss"],"showBackdrop":[4,"show-backdrop"],"spinner":[1025],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-toast",[[33,"ion-toast",{"overlayIndex":[2,"overlay-index"],"color":[513],"enterAnimation":[16],"leaveAnimation":[16],"cssClass":[1,"css-class"],"duration":[2],"header":[1],"message":[1],"keyboardClose":[4,"keyboard-close"],"position":[1],"buttons":[16],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-card_5",[[33,"ion-card",{"color":[513],"button":[4],"type":[1],"disabled":[4],"download":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1]}],[32,"ion-card-content"],[33,"ion-card-header",{"color":[513],"translucent":[4]}],[33,"ion-card-subtitle",{"color":[513]}],[33,"ion-card-title",{"color":[513]}]]],["ion-item-option_3",[[33,"ion-item-option",{"color":[513],"disabled":[4],"download":[1],"expandable":[4],"href":[1],"rel":[1],"target":[1],"type":[1]}],[32,"ion-item-options",{"side":[1],"fireSwipeEvent":[64]}],[0,"ion-item-sliding",{"disabled":[4],"state":[32],"getOpenAmount":[64],"getSlidingRatio":[64],"open":[64],"close":[64],"closeOpened":[64]}]]],["ion-infinite-scroll_2",[[32,"ion-infinite-scroll-content",{"loadingSpinner":[1025,"loading-spinner"],"loadingText":[1,"loading-text"]}],[0,"ion-infinite-scroll",{"threshold":[1],"disabled":[4],"position":[1],"isLoading":[32],"complete":[64]}]]],["ion-reorder_2",[[33,"ion-reorder",null,[[2,"click","onClick"]]],[0,"ion-reorder-group",{"disabled":[4],"state":[32],"complete":[64]}]]],["ion-segment_2",[[33,"ion-segment-button",{"disabled":[4],"layout":[1],"type":[1],"value":[1],"checked":[32]}],[33,"ion-segment",{"color":[513],"disabled":[4],"scrollable":[4],"swipeGesture":[4,"swipe-gesture"],"value":[1025],"activated":[32]}]]],["ion-tab-bar_2",[[33,"ion-tab-button",{"disabled":[4],"download":[1],"href":[1],"rel":[1],"layout":[1025],"selected":[1028],"tab":[1],"target":[1]},[[8,"ionTabBarChanged","onTabBarChanged"]]],[33,"ion-tab-bar",{"color":[513],"selectedTab":[1,"selected-tab"],"translucent":[4],"keyboardVisible":[32]}]]],["ion-chip",[[33,"ion-chip",{"color":[513],"outline":[4],"disabled":[4]}]]],["ion-modal",[[34,"ion-modal",{"overlayIndex":[2,"overlay-index"],"delegate":[16],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"component":[1],"componentProps":[16],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"showBackdrop":[4,"show-backdrop"],"animated":[4],"swipeToClose":[4,"swipe-to-close"],"presentingElement":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-popover",[[34,"ion-popover",{"delegate":[16],"overlayIndex":[2,"overlay-index"],"enterAnimation":[16],"leaveAnimation":[16],"component":[1],"componentProps":[16],"keyboardClose":[4,"keyboard-close"],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"event":[8],"showBackdrop":[4,"show-backdrop"],"translucent":[4],"animated":[4],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-searchbar",[[34,"ion-searchbar",{"color":[513],"animated":[4],"autocomplete":[1],"autocorrect":[1],"cancelButtonIcon":[1,"cancel-button-icon"],"cancelButtonText":[1,"cancel-button-text"],"clearIcon":[1,"clear-icon"],"debounce":[2],"disabled":[4],"inputmode":[1],"enterkeyhint":[1],"placeholder":[1],"searchIcon":[1,"search-icon"],"showCancelButton":[1,"show-cancel-button"],"showClearButton":[1,"show-clear-button"],"spellcheck":[4],"type":[1],"value":[1025],"focused":[32],"noAnimate":[32],"setFocus":[64],"getInputElement":[64]}]]],["ion-app_8",[[0,"ion-app"],[34,"ion-buttons",{"collapse":[4]}],[1,"ion-content",{"color":[513],"fullscreen":[4],"forceOverscroll":[1028,"force-overscroll"],"scrollX":[4,"scroll-x"],"scrollY":[4,"scroll-y"],"scrollEvents":[4,"scroll-events"],"getScrollElement":[64],"scrollToTop":[64],"scrollToBottom":[64],"scrollByPoint":[64],"scrollToPoint":[64]},[[8,"appload","onAppLoad"],[2,"click","onClick"]]],[36,"ion-footer",{"translucent":[4]}],[36,"ion-header",{"collapse":[1],"translucent":[4]}],[1,"ion-router-outlet",{"mode":[1025],"delegate":[16],"animated":[4],"animation":[16],"swipeHandler":[16],"commit":[64],"setRouteId":[64],"getRouteId":[64]}],[33,"ion-title",{"color":[513],"size":[1]}],[33,"ion-toolbar",{"color":[513]},[[0,"ionStyle","childrenStyle"]]]]],["ion-route_4",[[0,"ion-route",{"url":[1],"component":[1],"componentProps":[16],"beforeLeave":[16],"beforeEnter":[16]}],[0,"ion-route-redirect",{"from":[1],"to":[1]}],[0,"ion-router",{"root":[1],"useHash":[4,"use-hash"],"canTransition":[64],"push":[64],"back":[64],"printDebug":[64],"navChanged":[64]},[[8,"popstate","onPopState"],[4,"ionBackButton","onBackButton"]]],[1,"ion-router-link",{"color":[513],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1]}]]],["ion-avatar_3",[[33,"ion-avatar"],[33,"ion-badge",{"color":[513]}],[1,"ion-thumbnail"]]],["ion-col_3",[[1,"ion-col",{"offset":[1],"offsetXs":[1,"offset-xs"],"offsetSm":[1,"offset-sm"],"offsetMd":[1,"offset-md"],"offsetLg":[1,"offset-lg"],"offsetXl":[1,"offset-xl"],"pull":[1],"pullXs":[1,"pull-xs"],"pullSm":[1,"pull-sm"],"pullMd":[1,"pull-md"],"pullLg":[1,"pull-lg"],"pullXl":[1,"pull-xl"],"push":[1],"pushXs":[1,"push-xs"],"pushSm":[1,"push-sm"],"pushMd":[1,"push-md"],"pushLg":[1,"push-lg"],"pushXl":[1,"push-xl"],"size":[1],"sizeXs":[1,"size-xs"],"sizeSm":[1,"size-sm"],"sizeMd":[1,"size-md"],"sizeLg":[1,"size-lg"],"sizeXl":[1,"size-xl"]},[[9,"resize","onResize"]]],[1,"ion-grid",{"fixed":[4]}],[1,"ion-row"]]],["ion-nav_2",[[1,"ion-nav",{"delegate":[16],"swipeGesture":[1028,"swipe-gesture"],"animated":[4],"animation":[16],"rootParams":[16],"root":[1],"push":[64],"insert":[64],"insertPages":[64],"pop":[64],"popTo":[64],"popToRoot":[64],"removeIndex":[64],"setRoot":[64],"setPages":[64],"setRouteId":[64],"getRouteId":[64],"getActive":[64],"getByIndex":[64],"canGoBack":[64],"getPrevious":[64]}],[0,"ion-nav-link",{"component":[1],"componentProps":[16],"routerDirection":[1,"router-direction"],"routerAnimation":[16]}]]],["ion-slide_2",[[0,"ion-slide"],[36,"ion-slides",{"options":[8],"pager":[4],"scrollbar":[4],"update":[64],"updateAutoHeight":[64],"slideTo":[64],"slideNext":[64],"slidePrev":[64],"getActiveIndex":[64],"getPreviousIndex":[64],"length":[64],"isEnd":[64],"isBeginning":[64],"startAutoplay":[64],"stopAutoplay":[64],"lockSwipeToNext":[64],"lockSwipeToPrev":[64],"lockSwipes":[64],"getSwiper":[64]}]]],["ion-tab_2",[[1,"ion-tab",{"active":[1028],"delegate":[16],"tab":[1],"component":[1],"setActive":[64]}],[1,"ion-tabs",{"useRouter":[1028,"use-router"],"selectedTab":[32],"select":[64],"getTab":[64],"getSelected":[64],"setRouteId":[64],"getRouteId":[64]}]]],["ion-checkbox",[[33,"ion-checkbox",{"color":[513],"name":[1],"checked":[1028],"indeterminate":[1028],"disabled":[4],"value":[1]}]]],["ion-img",[[1,"ion-img",{"alt":[1],"src":[1],"loadSrc":[32],"loadError":[32]}]]],["ion-input",[[34,"ion-input",{"fireFocusEvents":[4,"fire-focus-events"],"color":[513],"accept":[1],"autocapitalize":[1],"autocomplete":[1],"autocorrect":[1],"autofocus":[4],"clearInput":[4,"clear-input"],"clearOnEdit":[4,"clear-on-edit"],"debounce":[2],"disabled":[4],"enterkeyhint":[1],"inputmode":[1],"max":[1],"maxlength":[2],"min":[1],"minlength":[2],"multiple":[4],"name":[1],"pattern":[1],"placeholder":[1],"readonly":[4],"required":[4],"spellcheck":[4],"step":[1],"size":[2],"type":[1],"value":[1032],"hasFocus":[32],"setFocus":[64],"setBlur":[64],"getInputElement":[64]}]]],["ion-progress-bar",[[33,"ion-progress-bar",{"type":[1],"reversed":[4],"value":[2],"buffer":[2],"color":[513]}]]],["ion-range",[[33,"ion-range",{"color":[513],"debounce":[2],"name":[1],"dualKnobs":[4,"dual-knobs"],"min":[2],"max":[2],"pin":[4],"snaps":[4],"step":[2],"ticks":[4],"disabled":[4],"value":[1026],"ratioA":[32],"ratioB":[32],"pressedKnob":[32]}]]],["ion-split-pane",[[33,"ion-split-pane",{"contentId":[513,"content-id"],"disabled":[4],"when":[8],"visible":[32]}]]],["ion-text",[[1,"ion-text",{"color":[513]}]]],["ion-textarea",[[34,"ion-textarea",{"fireFocusEvents":[4,"fire-focus-events"],"color":[513],"autocapitalize":[1],"autofocus":[4],"clearOnEdit":[1028,"clear-on-edit"],"debounce":[2],"disabled":[4],"inputmode":[1],"enterkeyhint":[1],"maxlength":[2],"minlength":[2],"name":[1],"placeholder":[1],"readonly":[4],"required":[4],"spellcheck":[4],"cols":[2],"rows":[2],"wrap":[1],"autoGrow":[4,"auto-grow"],"value":[1025],"hasFocus":[32],"setFocus":[64],"setBlur":[64],"getInputElement":[64]}]]],["ion-toggle",[[33,"ion-toggle",{"color":[513],"name":[1],"checked":[1028],"disabled":[4],"value":[1],"activated":[32]}]]],["ion-virtual-scroll",[[0,"ion-virtual-scroll",{"approxItemHeight":[2,"approx-item-height"],"approxHeaderHeight":[2,"approx-header-height"],"approxFooterHeight":[2,"approx-footer-height"],"headerFn":[16],"footerFn":[16],"items":[16],"itemHeight":[16],"headerHeight":[16],"footerHeight":[16],"renderItem":[16],"renderHeader":[16],"renderFooter":[16],"nodeRender":[16],"domRender":[16],"totalHeight":[32],"positionForItem":[64],"checkRange":[64],"checkEnd":[64]},[[9,"resize","onResize"]]]]],["ion-datetime_3",[[34,"ion-picker",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"buttons":[16],"columns":[16],"cssClass":[1,"css-class"],"duration":[2],"showBackdrop":[4,"show-backdrop"],"backdropDismiss":[4,"backdrop-dismiss"],"animated":[4],"presented":[32],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64],"getColumn":[64]}],[33,"ion-datetime",{"name":[1],"disabled":[4],"readonly":[4],"min":[1025],"max":[1025],"displayFormat":[1,"display-format"],"displayTimezone":[1,"display-timezone"],"pickerFormat":[1,"picker-format"],"cancelText":[1,"cancel-text"],"doneText":[1,"done-text"],"yearValues":[8,"year-values"],"monthValues":[8,"month-values"],"dayValues":[8,"day-values"],"hourValues":[8,"hour-values"],"minuteValues":[8,"minute-values"],"monthNames":[1,"month-names"],"monthShortNames":[1,"month-short-names"],"dayNames":[1,"day-names"],"dayShortNames":[1,"day-short-names"],"pickerOptions":[16],"placeholder":[1],"value":[1025],"isExpanded":[32],"open":[64]}],[32,"ion-picker-column",{"col":[16]}]]],["ion-radio_2",[[33,"ion-radio",{"color":[513],"name":[1],"disabled":[4],"value":[8],"checked":[32],"buttonTabindex":[32],"setFocus":[64],"setButtonTabindex":[64]}],[0,"ion-radio-group",{"allowEmptySelection":[4,"allow-empty-selection"],"name":[1],"value":[1032]},[[4,"keydown","onKeydown"]]]]],["ion-spinner",[[1,"ion-spinner",{"color":[513],"duration":[2],"name":[1],"paused":[4]}]]],["ion-backdrop",[[33,"ion-backdrop",{"visible":[4],"tappable":[4],"stopPropagation":[4,"stop-propagation"]},[[2,"click","onMouseDown"]]]]],["ion-ripple-effect",[[1,"ion-ripple-effect",{"type":[1],"addRipple":[64]}]]],["ion-button_2",[[33,"ion-button",{"color":[513],"buttonType":[1025,"button-type"],"disabled":[516],"expand":[513],"fill":[1537],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"download":[1],"href":[1],"rel":[1],"shape":[513],"size":[513],"strong":[4],"target":[1],"type":[1]}],[1,"ion-icon",{"mode":[1025],"color":[1],"ariaLabel":[1537,"aria-label"],"ariaHidden":[513,"aria-hidden"],"ios":[1],"md":[1],"flipRtl":[4,"flip-rtl"],"name":[1],"src":[1],"icon":[8],"size":[1],"lazy":[4],"sanitize":[4],"svgContent":[32],"isVisible":[32]}]]],["ion-item_8",[[33,"ion-item-divider",{"color":[513],"sticky":[4]}],[32,"ion-item-group"],[33,"ion-note",{"color":[513]}],[1,"ion-skeleton-text",{"animated":[4]}],[49,"ion-item",{"color":[513],"button":[4],"detail":[4],"detailIcon":[1,"detail-icon"],"disabled":[4],"download":[1],"href":[1],"rel":[1],"lines":[1],"routerAnimation":[16],"routerDirection":[1,"router-direction"],"target":[1],"type":[1],"multipleInputs":[32]},[[0,"ionColor","labelColorChanged"],[0,"ionStyle","itemStyle"]]],[34,"ion-label",{"color":[513],"position":[1],"noAnimate":[32]}],[32,"ion-list",{"lines":[1],"inset":[4],"closeSlidingItems":[64]}],[33,"ion-list-header",{"color":[513],"lines":[1]}]]]]'), o);
  });
};

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/loader/index.js
(function() {
  if (typeof window !== "undefined" && window.Reflect !== void 0 && window.customElements !== void 0) {
    var a = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(a, [], this.constructor);
    };
    HTMLElement.prototype = a.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, a);
  }
})();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/ionicons/dist/index.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/ionicons/dist/esm-es5/index.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/ionicons/dist/esm-es5/utils-4f847845.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/ionicons/dist/esm-es5/index-468d974f.js
init_define_process_env();
var __extends = function() {
  var e = function(t, n) {
    e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e2, t2) {
      e2.__proto__ = t2;
    } || function(e2, t2) {
      for (var n2 in t2)
        if (Object.prototype.hasOwnProperty.call(t2, n2))
          e2[n2] = t2[n2];
    };
    return e(t, n);
  };
  return function(t, n) {
    if (typeof n !== "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}();
var queuePending = false;
var win2 = typeof window !== "undefined" ? window : {};
var doc = win2.document || { head: {} };
var plt2 = { $flags$: 0, $resourcesUrl$: "", jmp: function(e) {
  return e();
}, raf: function(e) {
  return requestAnimationFrame(e);
}, ael: function(e, t, n, r) {
  return e.addEventListener(t, n, r);
}, rel: function(e, t, n, r) {
  return e.removeEventListener(t, n, r);
}, ce: function(e, t) {
  return new CustomEvent(e, t);
} };
var promiseResolve2 = function(e) {
  return Promise.resolve(e);
};
var supportsConstructibleStylesheets = function() {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replace === "function";
  } catch (e) {
  }
  return false;
}();
var rootAppliedStyles = new WeakMap();
var hostRefs = new WeakMap();
var consoleError = function(e, t) {
  return (0, console.error)(e, t);
};
var cmpModules = new Map();
var styles = new Map();
var queueDomReads = [];
var queueDomWrites = [];
var queueTask = function(e, t) {
  return function(n) {
    e.push(n);
    if (!queuePending) {
      queuePending = true;
      if (t && plt2.$flags$ & 4) {
        nextTick(flush);
      } else {
        plt2.raf(flush);
      }
    }
  };
};
var consume = function(e) {
  for (var t = 0; t < e.length; t++) {
    try {
      e[t](performance.now());
    } catch (e2) {
      consoleError(e2);
    }
  }
  e.length = 0;
};
var flush = function() {
  consume(queueDomReads);
  {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt2.raf(flush);
    }
  }
};
var nextTick = function(e) {
  return promiseResolve2().then(e);
};
var writeTask = queueTask(queueDomWrites, true);

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/ionicons/dist/esm-es5/utils-4f847845.js
var CACHED_MAP;
var getIconMap = function() {
  if (typeof window === "undefined") {
    return new Map();
  } else {
    if (!CACHED_MAP) {
      var r = window;
      r.Ionicons = r.Ionicons || {};
      CACHED_MAP = r.Ionicons.map = r.Ionicons.map || new Map();
    }
    return CACHED_MAP;
  }
};
var addIcons = function(r) {
  var e = getIconMap();
  Object.keys(r).forEach(function(t) {
    return e.set(t, r[t]);
  });
};

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/ionicons/icons/index.mjs
init_define_process_env();
var arrowBackSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Arrow Back</title><path stroke-linecap='square' stroke-miterlimit='10' stroke-width='48' d='M244 400L100 256l144-144M120 256h292' class='ionicon-fill-none'/></svg>";
var caretBackSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Caret Back</title><path d='M368 64L144 256l224 192V64z'/></svg>";
var chevronBack = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Chevron Back</title><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M328 112L184 256l144 144' class='ionicon-fill-none'/></svg>";
var chevronForward = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Chevron Forward</title><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M184 112l144 144-144 144' class='ionicon-fill-none'/></svg>";
var close = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Close</title><path d='M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z'/></svg>";
var closeCircle = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Close Circle</title><path d='M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208 208-93.31 208-208S370.69 48 256 48zm75.31 260.69a16 16 0 11-22.62 22.62L256 278.63l-52.69 52.68a16 16 0 01-22.62-22.62L233.37 256l-52.68-52.69a16 16 0 0122.62-22.62L256 233.37l52.69-52.68a16 16 0 0122.62 22.62L278.63 256z'/></svg>";
var closeSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Close</title><path d='M400 145.49L366.51 112 256 222.51 145.49 112 112 145.49 222.51 256 112 366.51 145.49 400 256 289.49 366.51 400 400 366.51 289.49 256 400 145.49z'/></svg>";
var menuOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Menu</title><path stroke-linecap='round' stroke-miterlimit='10' d='M80 160h352M80 256h352M80 352h352' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
var menuSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Menu</title><path d='M64 384h384v-42.67H64zm0-106.67h384v-42.66H64zM64 128v42.67h384V128z'/></svg>";
var reorderThreeOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Reorder Three</title><path stroke-linecap='round' stroke-linejoin='round' d='M96 256h320M96 176h320M96 336h320' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
var reorderTwoSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Reorder Two</title><path stroke-linecap='square' stroke-linejoin='round' stroke-width='44' d='M118 304h276M118 208h276' class='ionicon-fill-none'/></svg>";
var searchOutline = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Search</title><path d='M221.09 64a157.09 157.09 0 10157.09 157.09A157.1 157.1 0 00221.09 64z' stroke-miterlimit='10' class='ionicon-fill-none ionicon-stroke-width'/><path stroke-linecap='round' stroke-miterlimit='10' d='M338.29 338.29L448 448' class='ionicon-fill-none ionicon-stroke-width'/></svg>";
var searchSharp = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><title>Search</title><path d='M464 428L339.92 303.9a160.48 160.48 0 0030.72-94.58C370.64 120.37 298.27 48 209.32 48S48 120.37 48 209.32s72.37 161.32 161.32 161.32a160.48 160.48 0 0094.58-30.72L428 464zM209.32 319.69a110.38 110.38 0 11110.37-110.37 110.5 110.5 0 01-110.37 110.37z'/></svg>";

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/index.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/index.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/cubic-bezier-eea9a7a9.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/index-f49d994d.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/gesture-controller-31cb6bb9.js
init_define_process_env();
var GestureController = function() {
  function t() {
    this.gestureId = 0;
    this.requestedStart = new Map();
    this.disabledGestures = new Map();
    this.disabledScroll = new Set();
  }
  t.prototype.createGesture = function(t2) {
    return new GestureDelegate(this, this.newID(), t2.name, t2.priority || 0, !!t2.disableScroll);
  };
  t.prototype.createBlocker = function(t2) {
    if (t2 === void 0) {
      t2 = {};
    }
    return new BlockerDelegate(this, this.newID(), t2.disable, !!t2.disableScroll);
  };
  t.prototype.start = function(t2, e, r) {
    if (!this.canStart(t2)) {
      this.requestedStart.delete(e);
      return false;
    }
    this.requestedStart.set(e, r);
    return true;
  };
  t.prototype.capture = function(t2, e, r) {
    if (!this.start(t2, e, r)) {
      return false;
    }
    var i = this.requestedStart;
    var s = -1e4;
    i.forEach(function(t3) {
      s = Math.max(s, t3);
    });
    if (s === r) {
      this.capturedId = e;
      i.clear();
      var l = new CustomEvent("ionGestureCaptured", { detail: { gestureName: t2 } });
      document.dispatchEvent(l);
      return true;
    }
    i.delete(e);
    return false;
  };
  t.prototype.release = function(t2) {
    this.requestedStart.delete(t2);
    if (this.capturedId === t2) {
      this.capturedId = void 0;
    }
  };
  t.prototype.disableGesture = function(t2, e) {
    var r = this.disabledGestures.get(t2);
    if (r === void 0) {
      r = new Set();
      this.disabledGestures.set(t2, r);
    }
    r.add(e);
  };
  t.prototype.enableGesture = function(t2, e) {
    var r = this.disabledGestures.get(t2);
    if (r !== void 0) {
      r.delete(e);
    }
  };
  t.prototype.disableScroll = function(t2) {
    this.disabledScroll.add(t2);
    if (this.disabledScroll.size === 1) {
      document.body.classList.add(BACKDROP_NO_SCROLL);
    }
  };
  t.prototype.enableScroll = function(t2) {
    this.disabledScroll.delete(t2);
    if (this.disabledScroll.size === 0) {
      document.body.classList.remove(BACKDROP_NO_SCROLL);
    }
  };
  t.prototype.canStart = function(t2) {
    if (this.capturedId !== void 0) {
      return false;
    }
    if (this.isDisabled(t2)) {
      return false;
    }
    return true;
  };
  t.prototype.isCaptured = function() {
    return this.capturedId !== void 0;
  };
  t.prototype.isScrollDisabled = function() {
    return this.disabledScroll.size > 0;
  };
  t.prototype.isDisabled = function(t2) {
    var e = this.disabledGestures.get(t2);
    if (e && e.size > 0) {
      return true;
    }
    return false;
  };
  t.prototype.newID = function() {
    this.gestureId++;
    return this.gestureId;
  };
  return t;
}();
var GestureDelegate = function() {
  function t(t2, e, r, i, s) {
    this.id = e;
    this.name = r;
    this.disableScroll = s;
    this.priority = i * 1e6 + e;
    this.ctrl = t2;
  }
  t.prototype.canStart = function() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.canStart(this.name);
  };
  t.prototype.start = function() {
    if (!this.ctrl) {
      return false;
    }
    return this.ctrl.start(this.name, this.id, this.priority);
  };
  t.prototype.capture = function() {
    if (!this.ctrl) {
      return false;
    }
    var t2 = this.ctrl.capture(this.name, this.id, this.priority);
    if (t2 && this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
    return t2;
  };
  t.prototype.release = function() {
    if (this.ctrl) {
      this.ctrl.release(this.id);
      if (this.disableScroll) {
        this.ctrl.enableScroll(this.id);
      }
    }
  };
  t.prototype.destroy = function() {
    this.release();
    this.ctrl = void 0;
  };
  return t;
}();
var BlockerDelegate = function() {
  function t(t2, e, r, i) {
    this.id = e;
    this.disable = r;
    this.disableScroll = i;
    this.ctrl = t2;
  }
  t.prototype.block = function() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (var t2 = 0, e = this.disable; t2 < e.length; t2++) {
        var r = e[t2];
        this.ctrl.disableGesture(r, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.disableScroll(this.id);
    }
  };
  t.prototype.unblock = function() {
    if (!this.ctrl) {
      return;
    }
    if (this.disable) {
      for (var t2 = 0, e = this.disable; t2 < e.length; t2++) {
        var r = e[t2];
        this.ctrl.enableGesture(r, this.id);
      }
    }
    if (this.disableScroll) {
      this.ctrl.enableScroll(this.id);
    }
  };
  t.prototype.destroy = function() {
    this.unblock();
    this.ctrl = void 0;
  };
  return t;
}();
var BACKDROP_NO_SCROLL = "backdrop-no-scroll";
var GESTURE_CONTROLLER = new GestureController();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/index-f49d994d.js
var addEventListener = function(e, r, t, a) {
  var n = supportsPassive(e) ? { capture: !!a.capture, passive: !!a.passive } : !!a.capture;
  var i;
  var u;
  if (e["__zone_symbol__addEventListener"]) {
    i = "__zone_symbol__addEventListener";
    u = "__zone_symbol__removeEventListener";
  } else {
    i = "addEventListener";
    u = "removeEventListener";
  }
  e[i](r, t, n);
  return function() {
    e[u](r, t, n);
  };
};
var supportsPassive = function(e) {
  if (_sPassive === void 0) {
    try {
      var r = Object.defineProperty({}, "passive", { get: function() {
        _sPassive = true;
      } });
      e.addEventListener("optsTest", function() {
        return;
      }, r);
    } catch (t) {
      _sPassive = false;
    }
  }
  return !!_sPassive;
};
var _sPassive;
var MOUSE_WAIT = 2e3;
var createPointerEvents = function(e, r, t, a, n) {
  var i;
  var u;
  var s;
  var v;
  var f;
  var o;
  var c;
  var l = 0;
  var d = function(a2) {
    l = Date.now() + MOUSE_WAIT;
    if (!r(a2)) {
      return;
    }
    if (!u && t) {
      u = addEventListener(e, "touchmove", t, n);
    }
    if (!s) {
      s = addEventListener(e, "touchend", p, n);
    }
    if (!v) {
      v = addEventListener(e, "touchcancel", p, n);
    }
  };
  var m = function(a2) {
    if (l > Date.now()) {
      return;
    }
    if (!r(a2)) {
      return;
    }
    if (!o && t) {
      o = addEventListener(getDocument(e), "mousemove", t, n);
    }
    if (!c) {
      c = addEventListener(getDocument(e), "mouseup", E, n);
    }
  };
  var p = function(e2) {
    _();
    if (a) {
      a(e2);
    }
  };
  var E = function(e2) {
    y();
    if (a) {
      a(e2);
    }
  };
  var _ = function() {
    if (u) {
      u();
    }
    if (s) {
      s();
    }
    if (v) {
      v();
    }
    u = s = v = void 0;
  };
  var y = function() {
    if (o) {
      o();
    }
    if (c) {
      c();
    }
    o = c = void 0;
  };
  var X = function() {
    _();
    y();
  };
  var Y = function(r2) {
    if (r2 === void 0) {
      r2 = true;
    }
    if (!r2) {
      if (i) {
        i();
      }
      if (f) {
        f();
      }
      i = f = void 0;
      X();
    } else {
      if (!i) {
        i = addEventListener(e, "touchstart", d, n);
      }
      if (!f) {
        f = addEventListener(e, "mousedown", m, n);
      }
    }
  };
  var b = function() {
    Y(false);
    a = t = r = void 0;
  };
  return { enable: Y, stop: X, destroy: b };
};
var getDocument = function(e) {
  return e instanceof Document ? e : e.ownerDocument;
};
var createPanRecognizer = function(e, r, t) {
  var a = t * (Math.PI / 180);
  var n = e === "x";
  var i = Math.cos(a);
  var u = r * r;
  var s = 0;
  var v = 0;
  var f = false;
  var o = 0;
  return { start: function(e2, r2) {
    s = e2;
    v = r2;
    o = 0;
    f = true;
  }, detect: function(e2, r2) {
    if (!f) {
      return false;
    }
    var t2 = e2 - s;
    var a2 = r2 - v;
    var c = t2 * t2 + a2 * a2;
    if (c < u) {
      return false;
    }
    var l = Math.sqrt(c);
    var d = (n ? t2 : a2) / l;
    if (d > i) {
      o = 1;
    } else if (d < -i) {
      o = -1;
    } else {
      o = 0;
    }
    f = false;
    return true;
  }, isGesture: function() {
    return o !== 0;
  }, getDirection: function() {
    return o;
  } };
};
var createGesture = function(e) {
  var r = false;
  var t = false;
  var a = true;
  var n = false;
  var i = Object.assign({ disableScroll: false, direction: "x", gesturePriority: 0, passive: true, maxAngle: 40, threshold: 10 }, e);
  var u = i.canStart;
  var s = i.onWillStart;
  var v = i.onStart;
  var f = i.onEnd;
  var o = i.notCaptured;
  var c = i.onMove;
  var l = i.threshold;
  var d = i.passive;
  var m = i.blurOnStart;
  var p = { type: "pan", startX: 0, startY: 0, startTime: 0, currentX: 0, currentY: 0, velocityX: 0, velocityY: 0, deltaX: 0, deltaY: 0, currentTime: 0, event: void 0, data: void 0 };
  var E = createPanRecognizer(i.direction, i.threshold, i.maxAngle);
  var _ = GESTURE_CONTROLLER.createGesture({ name: e.gestureName, priority: e.gesturePriority, disableScroll: e.disableScroll });
  var y = function(e2) {
    var r2 = now(e2);
    if (t || !a) {
      return false;
    }
    updateDetail(e2, p);
    p.startX = p.currentX;
    p.startY = p.currentY;
    p.startTime = p.currentTime = r2;
    p.velocityX = p.velocityY = p.deltaX = p.deltaY = 0;
    p.event = e2;
    if (u && u(p) === false) {
      return false;
    }
    _.release();
    if (!_.start()) {
      return false;
    }
    t = true;
    if (l === 0) {
      return b();
    }
    E.start(p.startX, p.startY);
    return true;
  };
  var X = function(e2) {
    if (r) {
      if (!n && a) {
        n = true;
        calcGestureData(p, e2);
        requestAnimationFrame(Y);
      }
      return;
    }
    calcGestureData(p, e2);
    if (E.detect(p.currentX, p.currentY)) {
      if (!E.isGesture() || !b()) {
        P();
      }
    }
  };
  var Y = function() {
    if (!r) {
      return;
    }
    n = false;
    if (c) {
      c(p);
    }
  };
  var b = function() {
    if (_ && !_.capture()) {
      return false;
    }
    r = true;
    a = false;
    p.startX = p.currentX;
    p.startY = p.currentY;
    p.startTime = p.currentTime;
    if (s) {
      s(p).then(L);
    } else {
      L();
    }
    return true;
  };
  var g = function() {
    if (typeof document !== "undefined") {
      var e2 = document.activeElement;
      if (e2 !== null && e2.blur) {
        e2.blur();
      }
    }
  };
  var L = function() {
    if (m) {
      g();
    }
    if (v) {
      v(p);
    }
    a = true;
  };
  var h = function() {
    r = false;
    t = false;
    n = false;
    a = true;
    _.release();
  };
  var T = function(e2) {
    var t2 = r;
    var n2 = a;
    h();
    if (!n2) {
      return;
    }
    calcGestureData(p, e2);
    if (t2) {
      if (f) {
        f(p);
      }
      return;
    }
    if (o) {
      o(p);
    }
  };
  var D = createPointerEvents(i.el, y, X, T, { capture: false, passive: d });
  var P = function() {
    h();
    D.stop();
    if (o) {
      o(p);
    }
  };
  return { enable: function(e2) {
    if (e2 === void 0) {
      e2 = true;
    }
    if (!e2) {
      if (r) {
        T(void 0);
      }
      h();
    }
    D.enable(e2);
  }, destroy: function() {
    _.destroy();
    D.destroy();
  } };
};
var calcGestureData = function(e, r) {
  if (!r) {
    return;
  }
  var t = e.currentX;
  var a = e.currentY;
  var n = e.currentTime;
  updateDetail(r, e);
  var i = e.currentX;
  var u = e.currentY;
  var s = e.currentTime = now(r);
  var v = s - n;
  if (v > 0 && v < 100) {
    var f = (i - t) / v;
    var o = (u - a) / v;
    e.velocityX = f * 0.7 + e.velocityX * 0.3;
    e.velocityY = o * 0.7 + e.velocityY * 0.3;
  }
  e.deltaX = i - e.startX;
  e.deltaY = u - e.startY;
  e.event = r;
};
var updateDetail = function(e, r) {
  var t = 0;
  var a = 0;
  if (e) {
    var n = e.changedTouches;
    if (n && n.length > 0) {
      var i = n[0];
      t = i.clientX;
      a = i.clientY;
    } else if (e.pageX !== void 0) {
      t = e.pageX;
      a = e.pageY;
    }
  }
  r.currentX = t;
  r.currentY = a;
};
var now = function(e) {
  return e.timeStamp || Date.now();
};

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/index-9e3fe806.js
init_define_process_env();
var IonicSafeString = function() {
  function e(e2) {
    this.value = e2;
  }
  return e;
}();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/index-0d58a5bf.js
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/hardware-back-button-4a6b37fb.js
init_define_process_env();
var MENU_BACK_BUTTON_PRIORITY = 99;

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/index-0d58a5bf.js
var baseAnimation = function(n) {
  return createAnimation().duration(n ? 400 : 300);
};
var menuOverlayAnimation = function(n) {
  var e;
  var r;
  var t = n.width + 8;
  var i = createAnimation();
  var a = createAnimation();
  if (n.isEndSide) {
    e = t + "px";
    r = "0px";
  } else {
    e = -t + "px";
    r = "0px";
  }
  i.addElement(n.menuInnerEl).fromTo("transform", "translateX(" + e + ")", "translateX(" + r + ")");
  var o = getIonMode(n);
  var u = o === "ios";
  var s = u ? 0.2 : 0.25;
  a.addElement(n.backdropEl).fromTo("opacity", 0.01, s);
  return baseAnimation(u).addAnimation([i, a]);
};
var menuPushAnimation = function(n) {
  var e;
  var r;
  var t = getIonMode(n);
  var i = n.width;
  if (n.isEndSide) {
    e = -i + "px";
    r = i + "px";
  } else {
    e = i + "px";
    r = -i + "px";
  }
  var a = createAnimation().addElement(n.menuInnerEl).fromTo("transform", "translateX(" + r + ")", "translateX(0px)");
  var o = createAnimation().addElement(n.contentEl).fromTo("transform", "translateX(0px)", "translateX(" + e + ")");
  var u = createAnimation().addElement(n.backdropEl).fromTo("opacity", 0.01, 0.32);
  return baseAnimation(t === "ios").addAnimation([a, o, u]);
};
var menuRevealAnimation = function(n) {
  var e = getIonMode(n);
  var r = n.width * (n.isEndSide ? -1 : 1) + "px";
  var t = createAnimation().addElement(n.contentEl).fromTo("transform", "translateX(0px)", "translateX(" + r + ")");
  return baseAnimation(e === "ios").addAnimation(t);
};
var createMenuController = function() {
  var n = new Map();
  var e = [];
  var r = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, c(n2)];
          case 1:
            e2 = r2.sent();
            if (e2) {
              return [2, e2.open()];
            }
            return [2, false];
        }
      });
    });
  };
  var t = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, n2 !== void 0 ? c(n2) : f()];
          case 1:
            e2 = r2.sent();
            if (e2 !== void 0) {
              return [2, e2.close()];
            }
            return [2, false];
        }
      });
    });
  };
  var i = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, c(n2)];
          case 1:
            e2 = r2.sent();
            if (e2) {
              return [2, e2.toggle()];
            }
            return [2, false];
        }
      });
    });
  };
  var a = function(n2, e2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var r2;
      return __generator(this, function(t2) {
        switch (t2.label) {
          case 0:
            return [4, c(e2)];
          case 1:
            r2 = t2.sent();
            if (r2) {
              r2.disabled = !n2;
            }
            return [2, r2];
        }
      });
    });
  };
  var o = function(n2, e2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var r2;
      return __generator(this, function(t2) {
        switch (t2.label) {
          case 0:
            return [4, c(e2)];
          case 1:
            r2 = t2.sent();
            if (r2) {
              r2.swipeGesture = n2;
            }
            return [2, r2];
        }
      });
    });
  };
  var u = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2, e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (!(n2 != null))
              return [3, 2];
            return [4, c(n2)];
          case 1:
            e2 = r2.sent();
            return [2, e2 !== void 0 && e2.isOpen()];
          case 2:
            return [4, f()];
          case 3:
            e2 = r2.sent();
            return [2, e2 !== void 0];
        }
      });
    });
  };
  var s = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var e2;
      return __generator(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, c(n2)];
          case 1:
            e2 = r2.sent();
            if (e2) {
              return [2, !e2.disabled];
            }
            return [2, false];
        }
      });
    });
  };
  var c = function(n2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var r2, t2;
      return __generator(this, function(i2) {
        switch (i2.label) {
          case 0:
            return [4, O()];
          case 1:
            i2.sent();
            if (n2 === "start" || n2 === "end") {
              r2 = E(function(e2) {
                return e2.side === n2 && !e2.disabled;
              });
              if (r2) {
                return [2, r2];
              }
              return [2, E(function(e2) {
                return e2.side === n2;
              })];
            } else if (n2 != null) {
              return [2, E(function(e2) {
                return e2.menuId === n2;
              })];
            }
            t2 = E(function(n3) {
              return !n3.disabled;
            });
            if (t2) {
              return [2, t2];
            }
            return [2, e.length > 0 ? e[0].el : void 0];
        }
      });
    });
  };
  var f = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, O()];
          case 1:
            n2.sent();
            return [2, g()];
        }
      });
    });
  };
  var d = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, O()];
          case 1:
            n2.sent();
            return [2, w()];
        }
      });
    });
  };
  var v = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, O()];
          case 1:
            n2.sent();
            return [2, A()];
        }
      });
    });
  };
  var l = function(e2, r2) {
    n.set(e2, r2);
  };
  var m = function(n2) {
    if (e.indexOf(n2) < 0) {
      if (!n2.disabled) {
        p(n2);
      }
      e.push(n2);
    }
  };
  var _ = function(n2) {
    var r2 = e.indexOf(n2);
    if (r2 > -1) {
      e.splice(r2, 1);
    }
  };
  var p = function(n2) {
    var r2 = n2.side;
    e.filter(function(e2) {
      return e2.side === r2 && e2 !== n2;
    }).forEach(function(n3) {
      return n3.disabled = true;
    });
  };
  var b = function(n2, e2, r2) {
    return __awaiter(void 0, void 0, void 0, function() {
      var t2;
      return __generator(this, function(i2) {
        switch (i2.label) {
          case 0:
            if (A()) {
              return [2, false];
            }
            if (!e2)
              return [3, 3];
            return [4, f()];
          case 1:
            t2 = i2.sent();
            if (!(t2 && n2.el !== t2))
              return [3, 3];
            return [4, t2.setOpen(false, false)];
          case 2:
            i2.sent();
            i2.label = 3;
          case 3:
            return [2, n2._setOpen(e2, r2)];
        }
      });
    });
  };
  var h = function(e2, r2) {
    var t2 = n.get(e2);
    if (!t2) {
      throw new Error("animation not registered");
    }
    var i2 = t2(r2);
    return i2;
  };
  var g = function() {
    return E(function(n2) {
      return n2._isOpen;
    });
  };
  var w = function() {
    return e.map(function(n2) {
      return n2.el;
    });
  };
  var A = function() {
    return e.some(function(n2) {
      return n2.isAnimating;
    });
  };
  var E = function(n2) {
    var r2 = e.find(n2);
    if (r2 !== void 0) {
      return r2.el;
    }
    return void 0;
  };
  var O = function() {
    return Promise.all(Array.from(document.querySelectorAll("ion-menu")).map(function(n2) {
      return new Promise(function(e2) {
        return componentOnReady(n2, e2);
      });
    }));
  };
  l("reveal", menuRevealAnimation);
  l("push", menuPushAnimation);
  l("overlay", menuOverlayAnimation);
  if (typeof document !== "undefined") {
    document.addEventListener("ionBackButton", function(n2) {
      var e2 = g();
      if (e2) {
        n2.detail.register(MENU_BACK_BUTTON_PRIORITY, function() {
          return e2.close();
        });
      }
    });
  }
  return { registerAnimation: l, get: c, getMenus: d, getOpen: f, isEnabled: s, swipeGesture: o, isAnimating: v, isOpen: u, enable: a, toggle: i, close: t, open: r, _getOpenSync: g, _createAnimation: h, _register: m, _unregister: _, _setOpen: b, _setActiveMenu: p };
};
var menuController = createMenuController();

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/overlays-e9ccff30.js
init_define_process_env();
var activeAnimations = new WeakMap();
var createController = function(e) {
  return { create: function(t) {
    return createOverlay(e, t);
  }, dismiss: function(t, r, n) {
    return dismissOverlay(document, t, r, e, n);
  }, getTop: function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(t) {
        return [2, getOverlay(document, e)];
      });
    });
  } };
};
var alertController = createController("ion-alert");
var actionSheetController = createController("ion-action-sheet");
var loadingController = createController("ion-loading");
var modalController = createController("ion-modal");
var pickerController = createController("ion-picker");
var popoverController = createController("ion-popover");
var toastController = createController("ion-toast");
var createOverlay = function(e, t) {
  if (typeof customElements !== "undefined") {
    return customElements.whenDefined(e).then(function() {
      var r = document.createElement(e);
      r.classList.add("overlay-hidden");
      Object.assign(r, t);
      getAppRoot(document).appendChild(r);
      return new Promise(function(e2) {
        return componentOnReady(r, e2);
      });
    });
  }
  return Promise.resolve();
};
var dismissOverlay = function(e, t, r, n, o) {
  var a = getOverlay(e, n, o);
  if (!a) {
    return Promise.reject("overlay does not exist");
  }
  return a.dismiss(t, r);
};
var getOverlays = function(e, t) {
  if (t === void 0) {
    t = "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast";
  }
  return Array.from(e.querySelectorAll(t)).filter(function(e2) {
    return e2.overlayIndex > 0;
  });
};
var getOverlay = function(e, t, r) {
  var n = getOverlays(e, t);
  return r === void 0 ? n[n.length - 1] : n.find(function(e2) {
    return e2.id === r;
  });
};
var getAppRoot = function(e) {
  return e.querySelector("ion-app") || e.body;
};

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/core/dist/esm-es5/index.js
var setupConfig = function(o) {
  var e = window;
  var r = e.Ionic;
  if (r && r.config && r.config.constructor.name !== "Object") {
    return;
  }
  e.Ionic = e.Ionic || {};
  e.Ionic.config = Object.assign(Object.assign({}, e.Ionic.config), o);
  return e.Ionic.config;
};

// ../../../../../Documents/CODE/ION/ION3-Photo/node_modules/@ionic/react/dist/index.esm.js
var import_react_dom = __toModule(require_react_dom());
var IonLifeCycleContext = import_react.default.createContext({
  onIonViewWillEnter: () => {
    return;
  },
  ionViewWillEnter: () => {
    return;
  },
  onIonViewDidEnter: () => {
    return;
  },
  ionViewDidEnter: () => {
    return;
  },
  onIonViewWillLeave: () => {
    return;
  },
  ionViewWillLeave: () => {
    return;
  },
  onIonViewDidLeave: () => {
    return;
  },
  ionViewDidLeave: () => {
    return;
  }
});
var DefaultIonLifeCycleContext = class {
  constructor() {
    this.ionViewWillEnterCallbacks = [];
    this.ionViewDidEnterCallbacks = [];
    this.ionViewWillLeaveCallbacks = [];
    this.ionViewDidLeaveCallbacks = [];
  }
  onIonViewWillEnter(callback) {
    if (callback.id) {
      const index = this.ionViewWillEnterCallbacks.findIndex((x) => x.id === callback.id);
      if (index > -1) {
        this.ionViewWillEnterCallbacks[index] = callback;
      } else {
        this.ionViewWillEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewWillEnterCallbacks.push(callback);
    }
  }
  ionViewWillEnter() {
    this.ionViewWillEnterCallbacks.forEach((cb) => cb());
  }
  onIonViewDidEnter(callback) {
    if (callback.id) {
      const index = this.ionViewDidEnterCallbacks.findIndex((x) => x.id === callback.id);
      if (index > -1) {
        this.ionViewDidEnterCallbacks[index] = callback;
      } else {
        this.ionViewDidEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewDidEnterCallbacks.push(callback);
    }
  }
  ionViewDidEnter() {
    this.ionViewDidEnterCallbacks.forEach((cb) => cb());
  }
  onIonViewWillLeave(callback) {
    if (callback.id) {
      const index = this.ionViewWillLeaveCallbacks.findIndex((x) => x.id === callback.id);
      if (index > -1) {
        this.ionViewWillLeaveCallbacks[index] = callback;
      } else {
        this.ionViewWillLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewWillLeaveCallbacks.push(callback);
    }
  }
  ionViewWillLeave() {
    this.ionViewWillLeaveCallbacks.forEach((cb) => cb());
  }
  onIonViewDidLeave(callback) {
    if (callback.id) {
      const index = this.ionViewDidLeaveCallbacks.findIndex((x) => x.id === callback.id);
      if (index > -1) {
        this.ionViewDidLeaveCallbacks[index] = callback;
      } else {
        this.ionViewDidLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewDidLeaveCallbacks.push(callback);
    }
  }
  ionViewDidLeave() {
    this.ionViewDidLeaveCallbacks.forEach((cb) => cb());
    this.componentCanBeDestroyed();
  }
  onComponentCanBeDestroyed(callback) {
    this.componentCanBeDestroyedCallback = callback;
  }
  componentCanBeDestroyed() {
    if (this.componentCanBeDestroyedCallback) {
      this.componentCanBeDestroyedCallback();
    }
  }
};
var withIonLifeCycle = (WrappedComponent) => {
  return class IonLifeCycle extends import_react.default.Component {
    constructor(props) {
      super(props);
      this.componentRef = import_react.default.createRef();
    }
    componentDidMount() {
      const element = this.componentRef.current;
      this.context.onIonViewWillEnter(() => {
        if (element && element.ionViewWillEnter) {
          element.ionViewWillEnter();
        }
      });
      this.context.onIonViewDidEnter(() => {
        if (element && element.ionViewDidEnter) {
          element.ionViewDidEnter();
        }
      });
      this.context.onIonViewWillLeave(() => {
        if (element && element.ionViewWillLeave) {
          element.ionViewWillLeave();
        }
      });
      this.context.onIonViewDidLeave(() => {
        if (element && element.ionViewDidLeave) {
          element.ionViewDidLeave();
        }
      });
    }
    render() {
      return import_react.default.createElement(IonLifeCycleContext.Consumer, null, (context) => {
        this.context = context;
        return import_react.default.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props));
      });
    }
  };
};
var useIonViewWillEnter = (callback, deps = []) => {
  const context = (0, import_react.useContext)(IonLifeCycleContext);
  const id = (0, import_react.useRef)();
  id.current = id.current || Math.floor(Math.random() * 1e6);
  (0, import_react.useEffect)(() => {
    callback.id = id.current;
    context.onIonViewWillEnter(callback);
  }, deps);
};
var useIonViewDidEnter = (callback, deps = []) => {
  const context = (0, import_react.useContext)(IonLifeCycleContext);
  const id = (0, import_react.useRef)();
  id.current = id.current || Math.floor(Math.random() * 1e6);
  (0, import_react.useEffect)(() => {
    callback.id = id.current;
    context.onIonViewDidEnter(callback);
  }, deps);
};
var useIonViewWillLeave = (callback, deps = []) => {
  const context = (0, import_react.useContext)(IonLifeCycleContext);
  const id = (0, import_react.useRef)();
  id.current = id.current || Math.floor(Math.random() * 1e6);
  (0, import_react.useEffect)(() => {
    callback.id = id.current;
    context.onIonViewWillLeave(callback);
  }, deps);
};
var useIonViewDidLeave = (callback, deps = []) => {
  const context = (0, import_react.useContext)(IonLifeCycleContext);
  const id = (0, import_react.useRef)();
  id.current = id.current || Math.floor(Math.random() * 1e6);
  (0, import_react.useEffect)(() => {
    callback.id = id.current;
    context.onIonViewDidLeave(callback);
  }, deps);
};
var NavContext = import_react.default.createContext({
  getIonRedirect: () => void 0,
  getIonRoute: () => void 0,
  getPageManager: () => void 0,
  getStackManager: () => void 0,
  goBack: (route) => {
    if (typeof window !== "undefined") {
      if (typeof route === "string") {
        window.location.pathname = route;
      } else {
        window.history.back();
      }
    }
  },
  navigate: (path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  },
  hasIonicRouter: () => false,
  routeInfo: void 0,
  setCurrentTab: () => void 0,
  changeTab: (_tab, path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  },
  resetTab: (_tab, path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  }
});
var dashToPascalCase = (str) => str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
var camelToDashCase = (str) => str.replace(/([A-Z])/g, (m) => `-${m[0].toLowerCase()}`);
var attachProps = (node, newProps, oldProps = {}) => {
  if (node instanceof Element) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className !== "") {
      node.className = className;
    }
    Object.keys(newProps).forEach((name) => {
      if (name === "children" || name === "style" || name === "ref" || name === "class" || name === "className" || name === "forwardedRef") {
        return;
      }
      if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
        const eventName = name.substring(2);
        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
        if (!isCoveredByReact(eventNameLc)) {
          syncEvent(node, eventNameLc, newProps[name]);
        }
      } else {
        const propType = typeof newProps[name];
        if (propType === "string") {
          node.setAttribute(camelToDashCase(name), newProps[name]);
        } else {
          node[name] = newProps[name];
        }
      }
    });
  }
};
var getClassName = (classList, newProps, oldProps) => {
  const newClassProp = newProps.className || newProps.class;
  const oldClassProp = oldProps.className || oldProps.class;
  const currentClasses = arrayToMap(classList);
  const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(" ") : []);
  const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(" ") : []);
  const finalClassNames = [];
  currentClasses.forEach((currentClass) => {
    if (incomingPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
      incomingPropClasses.delete(currentClass);
    } else if (!oldPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
    }
  });
  incomingPropClasses.forEach((s) => finalClassNames.push(s));
  return finalClassNames.join(" ");
};
var isCoveredByReact = (eventNameSuffix) => {
  if (typeof document === "undefined") {
    return true;
  } else {
    const eventName = "on" + eventNameSuffix;
    let isSupported = eventName in document;
    if (!isSupported) {
      const element = document.createElement("div");
      element.setAttribute(eventName, "return;");
      isSupported = typeof element[eventName] === "function";
    }
    return isSupported;
  }
};
var syncEvent = (node, eventName, newEventHandler) => {
  const eventStore = node.__events || (node.__events = {});
  const oldEventHandler = eventStore[eventName];
  if (oldEventHandler) {
    node.removeEventListener(eventName, oldEventHandler);
  }
  node.addEventListener(eventName, eventStore[eventName] = function handler(e) {
    if (newEventHandler) {
      newEventHandler.call(this, e);
    }
  });
};
var arrayToMap = (arr) => {
  const map = new Map();
  arr.forEach((s) => map.set(s, s));
  return map;
};
var createForwardRef = (ReactComponent, displayName) => {
  const forwardRef = (props, ref) => {
    return import_react.default.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  return import_react.default.forwardRef(forwardRef);
};
var setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref != null) {
    ref.current = value;
  }
};
var mergeRefs = (...refs) => {
  return (value) => {
    refs.forEach((ref) => {
      setRef(ref, value);
    });
  };
};
var isPlatform2 = (platform) => {
  return isPlatform(window, platform);
};
var getPlatforms2 = () => {
  return getPlatforms(window);
};
var getConfig = () => {
  if (typeof window !== "undefined") {
    const Ionic = window.Ionic;
    if (Ionic && Ionic.config) {
      return Ionic.config;
    }
  }
  return null;
};
var createReactComponent = (tagName, routerLinkComponent = false) => {
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends import_react.default.Component {
    constructor(props) {
      super(props);
      this.handleClick = (e) => {
        const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;
        if (routerLink !== void 0) {
          e.preventDefault();
          this.context.navigate(routerLink, routerDirection, void 0, routerAnimation, routerOptions);
        }
      };
      this.ref = import_react.default.createRef();
      this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
    }
    componentDidMount() {
      this.componentDidUpdate(this.props);
    }
    componentDidUpdate(prevProps) {
      const node = this.ref.current;
      attachProps(node, this.props, prevProps);
    }
    render() {
      const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
      const propsToPass = Object.keys(cProps).reduce((acc, name) => {
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (isCoveredByReact(eventName)) {
            acc[name] = cProps[name];
          }
        } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
          acc[camelToDashCase(name)] = cProps[name];
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
      if (routerLinkComponent) {
        if (this.props.routerLink && !this.props.href) {
          newProps.href = this.props.routerLink;
        }
        if (newProps.onClick) {
          const oldClick = newProps.onClick;
          newProps.onClick = (e) => {
            oldClick(e);
            if (!e.defaultPrevented) {
              this.handleClick(e);
            }
          };
        } else {
          newProps.onClick = this.handleClick;
        }
      }
      return import_react.default.createElement(tagName, newProps, children);
    }
    static get displayName() {
      return displayName;
    }
    static get contextType() {
      return NavContext;
    }
  };
  return createForwardRef(ReactComponent, displayName);
};
var IonApp = createReactComponent("ion-app");
var IonTab = createReactComponent("ion-tab");
var IonRouterLink = createReactComponent("ion-router-link", true);
var IonAvatar = createReactComponent("ion-avatar");
var IonBackdrop = createReactComponent("ion-backdrop");
var IonBadge = createReactComponent("ion-badge");
var IonButton = createReactComponent("ion-button", true);
var IonButtons = createReactComponent("ion-buttons");
var IonCard = createReactComponent("ion-card", true);
var IonCardContent = createReactComponent("ion-card-content");
var IonCardHeader = createReactComponent("ion-card-header");
var IonCardSubtitle = createReactComponent("ion-card-subtitle");
var IonCardTitle = createReactComponent("ion-card-title");
var IonCheckbox = createReactComponent("ion-checkbox");
var IonCol = createReactComponent("ion-col");
var IonContent = createReactComponent("ion-content");
var IonChip = createReactComponent("ion-chip");
var IonDatetime = createReactComponent("ion-datetime");
var IonFab = createReactComponent("ion-fab");
var IonFabButton = createReactComponent("ion-fab-button", true);
var IonFabList = createReactComponent("ion-fab-list");
var IonFooter = createReactComponent("ion-footer");
var IonGrid = createReactComponent("ion-grid");
var IonHeader = createReactComponent("ion-header");
var IonImg = createReactComponent("ion-img");
var IonInfiniteScroll = createReactComponent("ion-infinite-scroll");
var IonInfiniteScrollContent = createReactComponent("ion-infinite-scroll-content");
var IonInput = createReactComponent("ion-input");
var IonItem = createReactComponent("ion-item", true);
var IonItemDivider = createReactComponent("ion-item-divider");
var IonItemGroup = createReactComponent("ion-item-group");
var IonItemOption = createReactComponent("ion-item-option", true);
var IonItemOptions = createReactComponent("ion-item-options");
var IonItemSliding = createReactComponent("ion-item-sliding");
var IonLabel = createReactComponent("ion-label");
var IonList = createReactComponent("ion-list");
var IonListHeader = createReactComponent("ion-list-header");
var IonMenu = createReactComponent("ion-menu");
var IonMenuButton = createReactComponent("ion-menu-button");
var IonMenuToggle = createReactComponent("ion-menu-toggle");
var IonNote = createReactComponent("ion-note");
var IonPickerColumn = createReactComponent("ion-picker-column");
var IonNav = createReactComponent("ion-nav");
var IonProgressBar = createReactComponent("ion-progress-bar");
var IonRadio = createReactComponent("ion-radio");
var IonRadioGroup = createReactComponent("ion-radio-group");
var IonRange = createReactComponent("ion-range");
var IonRefresher = createReactComponent("ion-refresher");
var IonRefresherContent = createReactComponent("ion-refresher-content");
var IonReorder = createReactComponent("ion-reorder");
var IonReorderGroup = createReactComponent("ion-reorder-group");
var IonRippleEffect = createReactComponent("ion-ripple-effect");
var IonRow = createReactComponent("ion-row");
var IonSearchbar = createReactComponent("ion-searchbar");
var IonSegment = createReactComponent("ion-segment");
var IonSegmentButton = createReactComponent("ion-segment-button");
var IonSelect = createReactComponent("ion-select");
var IonSelectOption = createReactComponent("ion-select-option");
var IonSelectPopover = createReactComponent("ion-select-popover");
var IonSkeletonText = createReactComponent("ion-skeleton-text");
var IonSlide = createReactComponent("ion-slide");
var IonSlides = createReactComponent("ion-slides");
var IonSpinner = createReactComponent("ion-spinner");
var IonSplitPane = createReactComponent("ion-split-pane");
var IonText = createReactComponent("ion-text");
var IonTextarea = createReactComponent("ion-textarea");
var IonThumbnail = createReactComponent("ion-thumbnail");
var IonTitle = createReactComponent("ion-title");
var IonToggle = createReactComponent("ion-toggle");
var IonToolbar = createReactComponent("ion-toolbar");
var IonVirtualScroll = createReactComponent("ion-virtual-scroll");
var createControllerComponent = (displayName, controller) => {
  const didDismissEventName = `on${displayName}DidDismiss`;
  const didPresentEventName = `on${displayName}DidPresent`;
  const willDismissEventName = `on${displayName}WillDismiss`;
  const willPresentEventName = `on${displayName}WillPresent`;
  class Overlay extends import_react.default.Component {
    constructor(props) {
      super(props);
      this.isUnmounted = false;
      this.handleDismiss = this.handleDismiss.bind(this);
    }
    static get displayName() {
      return displayName;
    }
    async componentDidMount() {
      const { isOpen } = this.props;
      if (isOpen) {
        this.present();
      }
    }
    componentWillUnmount() {
      this.isUnmounted = true;
      if (this.overlay) {
        this.overlay.dismiss();
      }
    }
    async componentDidUpdate(prevProps) {
      if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
        this.present(prevProps);
      }
      if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
        await this.overlay.dismiss();
      }
    }
    handleDismiss(event) {
      if (this.props.onDidDismiss) {
        this.props.onDidDismiss(event);
      }
      setRef(this.props.forwardedRef, null);
    }
    async present(prevProps) {
      const _a = this.props, cProps = __rest(_a, ["isOpen", "onDidDismiss", "onDidPresent", "onWillDismiss", "onWillPresent"]);
      this.overlay = await controller.create(Object.assign({}, cProps));
      attachProps(this.overlay, {
        [didDismissEventName]: this.handleDismiss,
        [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e),
        [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e),
        [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e)
      }, prevProps);
      if (this.props.isOpen === true && this.isUnmounted === false) {
        setRef(this.props.forwardedRef, this.overlay);
        await this.overlay.present();
      }
    }
    render() {
      return null;
    }
  }
  return import_react.default.forwardRef((props, ref) => {
    return import_react.default.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));
  });
};
var IonAlert = createControllerComponent("IonAlert", alertController);
var IonLoading = createControllerComponent("IonLoading", loadingController);
var toastController2 = {
  create: (options) => toastController.create(options),
  dismiss: (data, role, id) => toastController.dismiss(data, role, id),
  getTop: () => toastController.getTop()
};
var IonToast = createControllerComponent("IonToast", toastController2);
var IonPicker = createControllerComponent("IonPicker", pickerController);
var createOverlayComponent = (displayName, controller) => {
  const didDismissEventName = `on${displayName}DidDismiss`;
  const didPresentEventName = `on${displayName}DidPresent`;
  const willDismissEventName = `on${displayName}WillDismiss`;
  const willPresentEventName = `on${displayName}WillPresent`;
  let isDismissing = false;
  class Overlay extends import_react.default.Component {
    constructor(props) {
      super(props);
      if (typeof document !== "undefined") {
        this.el = document.createElement("div");
      }
      this.handleDismiss = this.handleDismiss.bind(this);
    }
    static get displayName() {
      return displayName;
    }
    componentDidMount() {
      if (this.props.isOpen) {
        this.present();
      }
    }
    componentWillUnmount() {
      if (this.overlay) {
        this.overlay.dismiss();
      }
    }
    handleDismiss(event) {
      if (this.props.onDidDismiss) {
        this.props.onDidDismiss(event);
      }
      setRef(this.props.forwardedRef, null);
    }
    shouldComponentUpdate(nextProps) {
      if (this.overlay && nextProps.isOpen !== this.props.isOpen && nextProps.isOpen === false) {
        isDismissing = true;
      }
      return true;
    }
    async componentDidUpdate(prevProps) {
      if (this.overlay) {
        attachProps(this.overlay, this.props, prevProps);
      }
      if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
        this.present(prevProps);
      }
      if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
        await this.overlay.dismiss();
        isDismissing = false;
        this.forceUpdate();
      }
    }
    async present(prevProps) {
      const _a = this.props, cProps = __rest(_a, ["children", "isOpen", "onDidDismiss", "onDidPresent", "onWillDismiss", "onWillPresent"]);
      const elementProps = Object.assign(Object.assign({}, cProps), { ref: this.props.forwardedRef, [didDismissEventName]: this.handleDismiss, [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e), [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e), [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e) });
      this.overlay = await controller.create(Object.assign(Object.assign({}, elementProps), { component: this.el, componentProps: {} }));
      setRef(this.props.forwardedRef, this.overlay);
      attachProps(this.overlay, elementProps, prevProps);
      await this.overlay.present();
    }
    render() {
      return import_react_dom.default.createPortal(this.props.isOpen || isDismissing ? this.props.children : null, this.el);
    }
  }
  return import_react.default.forwardRef((props, ref) => {
    return import_react.default.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));
  });
};
var actionSheetController2 = {
  create: (options) => actionSheetController.create(options),
  dismiss: (data, role, id) => actionSheetController.dismiss(data, role, id),
  getTop: () => actionSheetController.getTop()
};
var IonActionSheet = createOverlayComponent("IonActionSheet", actionSheetController2);
var IonModal = createOverlayComponent("IonModal", modalController);
var IonPopover = createOverlayComponent("IonPopover", popoverController);
var StackContext = import_react.default.createContext({
  registerIonPage: () => void 0,
  isInOutlet: () => false
});
var PageManager = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this.ionPageElementRef = import_react.default.createRef();
    this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);
  }
  componentDidMount() {
    if (this.ionPageElementRef.current) {
      if (this.context.isInOutlet()) {
        this.ionPageElementRef.current.classList.add("ion-page-invisible");
      }
      this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);
      this.ionPageElementRef.current.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  componentWillUnmount() {
    if (this.ionPageElementRef.current) {
      this.ionPageElementRef.current.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = __rest(_a, ["className", "children", "routeInfo", "forwardedRef"]);
    return import_react.default.createElement(IonLifeCycleContext.Consumer, null, (context) => {
      this.ionLifeCycleContext = context;
      return import_react.default.createElement("div", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props), children);
    });
  }
  static get contextType() {
    return StackContext;
  }
};
var IonPageInternal = class extends import_react.default.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const _a = this.props, { className, children, forwardedRef } = _a, props = __rest(_a, ["className", "children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? import_react.default.createElement(PageManager, Object.assign({ className: className ? `${className}` : "", routeInfo: this.context.routeInfo, forwardedRef }, props), children) : import_react.default.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : "ion-page", ref: forwardedRef }, props), children);
  }
  static get displayName() {
    return "IonPage";
  }
  static get contextType() {
    return NavContext;
  }
};
var IonPage = createForwardRef(IonPageInternal, "IonPage");
var IonTabsContext = import_react.default.createContext({
  activeTab: void 0,
  selectTab: () => false
});
var IonTabButtonInner = createReactComponent("ion-tab-button");
var IonTabBarInner = createReactComponent("ion-tab-bar");
var IonBackButtonInner = createReactComponent("ion-back-button");
var IonRouterOutletInner = createReactComponent("ion-router-outlet");
var IonIconInner = createReactComponent("ion-icon");
var OutletPageManager = class extends import_react.default.Component {
  constructor(props) {
    super(props);
  }
  componentDidMount() {
    if (this.ionRouterOutlet) {
      setTimeout(() => {
        this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);
      }, 25);
      this.ionRouterOutlet.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  componentWillUnmount() {
    if (this.ionRouterOutlet) {
      this.ionRouterOutlet.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a = this.props, { StackManager, children, routeInfo } = _a, props = __rest(_a, ["StackManager", "children", "routeInfo"]);
    return import_react.default.createElement(IonLifeCycleContext.Consumer, null, (context) => {
      this.ionLifeCycleContext = context;
      return import_react.default.createElement(StackManager, { routeInfo }, import_react.default.createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => this.ionRouterOutlet = val }, props), children));
    });
  }
  static get contextType() {
    return StackContext;
  }
};
var IonRouterOutletContainer = class extends import_react.default.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const StackManager = this.context.getStackManager();
    const _a = this.props, { children, forwardedRef } = _a, props = __rest(_a, ["children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? props.ionPage ? import_react.default.createElement(OutletPageManager, Object.assign({ StackManager, routeInfo: this.context.routeInfo }, props), children) : import_react.default.createElement(StackManager, { routeInfo: this.context.routeInfo }, import_react.default.createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef }), children)) : import_react.default.createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
};
var IonRouterOutlet = createForwardRef(IonRouterOutletContainer, "IonRouterOutlet");
var IonTabButton = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);
  }
  handleIonTabButtonClick() {
    if (this.props.onClick) {
      this.props.onClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          tab: this.props.tab,
          href: this.props.href,
          routeOptions: this.props.routerOptions
        }
      }));
    }
  }
  render() {
    const _a = this.props, rest = __rest(_a, ["onClick"]);
    return import_react.default.createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest));
  }
  static get displayName() {
    return "IonTabButton";
  }
};
var IonTabBarUnwrapped = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this.setActiveTabOnContext = (_tab) => {
    };
    const tabs = {};
    import_react.default.Children.forEach(props.children, (child) => {
      var _a, _b, _c, _d;
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        tabs[child.props.tab] = {
          originalHref: child.props.href,
          currentHref: child.props.href,
          originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : void 0,
          currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname) ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : void 0
        };
      }
    });
    this.state = {
      tabs
    };
    this.onTabButtonClick = this.onTabButtonClick.bind(this);
    this.renderTabButton = this.renderTabButton.bind(this);
    this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);
    this.selectTab = this.selectTab.bind(this);
  }
  componentDidMount() {
    const tabs = this.state.tabs;
    const tabKeys = Object.keys(tabs);
    const activeTab = tabKeys.find((key) => {
      const href = tabs[key].originalHref;
      return this.props.routeInfo.pathname.startsWith(href);
    });
    if (activeTab) {
      this.setState({
        activeTab
      });
    }
  }
  componentDidUpdate() {
    if (this.state.activeTab) {
      this.setActiveTabOnContext(this.state.activeTab);
    }
  }
  selectTab(tab) {
    const tabUrl = this.state.tabs[tab];
    if (tabUrl) {
      this.onTabButtonClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          href: tabUrl.currentHref,
          tab,
          selected: tab === this.state.activeTab,
          routeOptions: void 0
        }
      }));
      return true;
    }
    return false;
  }
  static getDerivedStateFromProps(props, state) {
    var _a, _b, _c;
    const tabs = Object.assign({}, state.tabs);
    const tabKeys = Object.keys(state.tabs);
    const activeTab = tabKeys.find((key) => {
      const href = state.tabs[key].originalHref;
      return props.routeInfo.pathname.startsWith(href);
    });
    import_react.default.Children.forEach(props.children, (child) => {
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const tab = tabs[child.props.tab];
        if (!tab || tab.originalHref !== child.props.href) {
          tabs[child.props.tab] = {
            originalHref: child.props.href,
            currentHref: child.props.href,
            originalRouteOptions: child.props.routeOptions,
            currentRouteOptions: child.props.routeOptions
          };
        }
      }
    });
    const { activeTab: prevActiveTab } = state;
    if (activeTab && prevActiveTab) {
      const prevHref = state.tabs[prevActiveTab].currentHref;
      const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;
      if (activeTab !== prevActiveTab || prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) || prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {
        tabs[activeTab] = {
          originalHref: tabs[activeTab].originalHref,
          currentHref: props.routeInfo.pathname + (props.routeInfo.search || ""),
          originalRouteOptions: tabs[activeTab].originalRouteOptions,
          currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions
        };
        if (props.routeInfo.routeAction === "pop" && activeTab !== prevActiveTab) {
          tabs[prevActiveTab] = {
            originalHref: tabs[prevActiveTab].originalHref,
            currentHref: tabs[prevActiveTab].originalHref,
            originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,
            currentRouteOptions: tabs[prevActiveTab].currentRouteOptions
          };
        }
      }
    }
    activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);
    return {
      activeTab,
      tabs
    };
  }
  onTabButtonClick(e) {
    const tappedTab = this.state.tabs[e.detail.tab];
    const originalHref = tappedTab.originalHref;
    const currentHref = e.detail.href;
    const { activeTab: prevActiveTab } = this.state;
    if (prevActiveTab === e.detail.tab) {
      if (originalHref !== currentHref) {
        this.context.resetTab(e.detail.tab, originalHref, tappedTab.originalRouteOptions);
      }
    } else {
      if (this.props.onIonTabsWillChange) {
        this.props.onIonTabsWillChange(new CustomEvent("ionTabWillChange", { detail: { tab: e.detail.tab } }));
      }
      if (this.props.onIonTabsDidChange) {
        this.props.onIonTabsDidChange(new CustomEvent("ionTabDidChange", { detail: { tab: e.detail.tab } }));
      }
      this.setActiveTabOnContext(e.detail.tab);
      this.context.changeTab(e.detail.tab, currentHref, e.detail.routeOptions);
    }
  }
  renderTabButton(activeTab) {
    return (child) => {
      var _a, _b;
      if (child != null && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const href = child.props.tab === activeTab ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;
        const routeOptions = child.props.tab === activeTab ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;
        return import_react.default.cloneElement(child, {
          href,
          routeOptions,
          onClick: this.onTabButtonClick
        });
      }
      return null;
    };
  }
  render() {
    const { activeTab } = this.state;
    return import_react.default.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), import_react.default.Children.map(this.props.children, this.renderTabButton(activeTab)));
  }
  static get contextType() {
    return NavContext;
  }
};
var IonTabBarContainer = import_react.default.memo((_a) => {
  var { forwardedRef } = _a, props = __rest(_a, ["forwardedRef"]);
  const context = (0, import_react.useContext)(NavContext);
  return import_react.default.createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props, { routeInfo: props.routeInfo || context.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context.setCurrentTab }), props.children);
});
var IonTabBar = createForwardRef(IonTabBarContainer, "IonTabBar");
var IonTabsElement = class extends HTMLElement {
  constructor() {
    super();
  }
};
if (window && window.customElements) {
  const element = customElements.get("ion-tabs");
  if (!element) {
    customElements.define("ion-tabs", IonTabsElement);
  }
}
var hostStyles = {
  display: "flex",
  position: "absolute",
  top: "0",
  left: "0",
  right: "0",
  bottom: "0",
  flexDirection: "column",
  width: "100%",
  height: "100%",
  contain: "layout size style"
};
var tabsInner = {
  position: "relative",
  flex: 1,
  contain: "layout size style"
};
var IonTabs = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.routerOutletRef = import_react.default.createRef();
    this.tabBarRef = import_react.default.createRef();
    this.ionTabContextState = {
      activeTab: void 0,
      selectTab: () => false
    };
  }
  componentDidMount() {
    if (this.tabBarRef.current) {
      this.ionTabContextState.activeTab = this.tabBarRef.current.state.activeTab;
      this.tabBarRef.current.setActiveTabOnContext = (tab) => {
        this.ionTabContextState.activeTab = tab;
      };
      this.ionTabContextState.selectTab = this.tabBarRef.current.selectTab;
    }
  }
  render() {
    let outlet;
    let tabBar;
    const _a = this.props, { className, onIonTabsDidChange, onIonTabsWillChange } = _a, props = __rest(_a, ["className", "onIonTabsDidChange", "onIonTabsWillChange"]);
    const children = typeof this.props.children === "function" ? this.props.children(this.ionTabContextState) : this.props.children;
    import_react.default.Children.forEach(children, (child) => {
      if (child == null || typeof child !== "object" || !child.hasOwnProperty("type")) {
        return;
      }
      if (child.type === IonRouterOutlet || child.type.isRouterOutlet) {
        outlet = import_react.default.cloneElement(child, { tabs: true });
      } else if (child.type === import_react.Fragment && child.props.children[0].type === IonRouterOutlet) {
        outlet = child.props.children[0];
      }
      let childProps = {
        ref: this.tabBarRef
      };
      if (onIonTabsDidChange !== void 0) {
        childProps = Object.assign(Object.assign({}, childProps), { onIonTabsDidChange });
      }
      if (onIonTabsWillChange !== void 0) {
        childProps = Object.assign(Object.assign({}, childProps), { onIonTabsWillChange });
      }
      if (child.type === IonTabBar || child.type.isTabBar) {
        tabBar = import_react.default.cloneElement(child, childProps);
      } else if (child.type === import_react.Fragment && (child.props.children[1].type === IonTabBar || child.props.children[1].type.isTabBar)) {
        tabBar = import_react.default.cloneElement(child.props.children[1], childProps);
      }
    });
    if (!outlet) {
      throw new Error("IonTabs must contain an IonRouterOutlet");
    }
    if (!tabBar) {
      throw new Error("IonTabs needs a IonTabBar");
    }
    return import_react.default.createElement(IonTabsContext.Provider, { value: this.ionTabContextState }, this.context.hasIonicRouter() ? import_react.default.createElement(PageManager, Object.assign({ className: className ? `${className}` : "", routeInfo: this.context.routeInfo }, props), import_react.default.createElement("ion-tabs", { className: "ion-tabs", style: hostStyles }, tabBar.props.slot === "top" ? tabBar : null, import_react.default.createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet), tabBar.props.slot === "bottom" ? tabBar : null)) : import_react.default.createElement("div", Object.assign({ className: className ? `${className}` : "ion-tabs" }, props, { style: hostStyles }), tabBar.props.slot === "top" ? tabBar : null, import_react.default.createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet), tabBar.props.slot === "bottom" ? tabBar : null));
  }
  static get contextType() {
    return NavContext;
  }
};
var IonBackButton = (() => class extends import_react.default.Component {
  constructor() {
    super(...arguments);
    this.clickButton = (e) => {
      const { defaultHref, routerAnimation } = this.props;
      if (this.context.hasIonicRouter()) {
        e.stopPropagation();
        this.context.goBack(defaultHref, routerAnimation);
      } else if (defaultHref !== void 0) {
        window.location.href = defaultHref;
      }
    };
  }
  render() {
    return import_react.default.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props));
  }
  static get displayName() {
    return "IonBackButton";
  }
  static get contextType() {
    return NavContext;
  }
})();
var isDevMode = () => {
  return process && define_process_env_default && true;
};
var warnings = {};
var deprecationWarning = (key, message) => {
  if (isDevMode()) {
    if (!warnings[key]) {
      console.warn(message);
      warnings[key] = true;
    }
  }
};
var IonIconContainer = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    if (this.props.name) {
      deprecationWarning("icon-name", 'In Ionic React, you import icons from "ionicons/icons" and set the icon you imported to the "icon" property. Setting the "name" property has no effect.');
    }
  }
  render() {
    var _a, _b;
    const _c = this.props, { icon, ios, md } = _c, rest = __rest(_c, ["icon", "ios", "md"]);
    let iconToUse;
    if (ios || md) {
      if (isPlatform2("ios")) {
        iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;
      } else {
        iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;
      }
    } else {
      iconToUse = icon;
    }
    return import_react.default.createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
};
var IonIcon = createForwardRef(IonIconContainer, "IonIcon");
var IonRoute = class extends import_react.default.PureComponent {
  render() {
    const IonRouteInner = this.context.getIonRoute();
    if (!this.context.hasIonicRouter() || !IonRoute) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRoute>");
      return null;
    }
    return import_react.default.createElement(IonRouteInner, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
};
var IonRedirect = class extends import_react.default.PureComponent {
  render() {
    const IonRedirectInner = this.context.getIonRedirect();
    if (!this.context.hasIonicRouter() || !IonRedirect) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRedirect>");
      return null;
    }
    return import_react.default.createElement(IonRedirectInner, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
};
var IonRouterContext = import_react.default.createContext({
  routeInfo: void 0,
  push: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  back: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  canGoBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  nativeBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  }
});
function useIonRouter() {
  const context = (0, import_react.useContext)(IonRouterContext);
  return {
    back: context.back,
    push: context.push,
    goBack: context.back,
    canGoBack: context.canGoBack,
    routeInfo: context.routeInfo
  };
}
var CreateAnimation = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this.nodes = new Map();
    this.animation = createAnimation(props.id);
  }
  setupAnimation(props) {
    const animation = this.animation;
    if (this.nodes.size > 0) {
      animation.addElement(Array.from(this.nodes.values()));
    }
    checkConfig(animation, props);
    checkPlayback(animation, props);
  }
  componentDidMount() {
    const props = this.props;
    this.setupAnimation(props);
  }
  componentDidUpdate(prevProps) {
    const animation = this.animation;
    const props = this.props;
    checkConfig(animation, props, prevProps);
    checkProgress(animation, props, prevProps);
    checkPlayback(animation, props, prevProps);
  }
  render() {
    const { children } = this.props;
    return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.Children.map(children, (child, id) => import_react.default.cloneElement(child, { ref: (el) => this.nodes.set(id, el) })));
  }
};
var checkConfig = (animation, currentProps = {}, prevProps = {}) => {
  const reservedProps = [
    "children",
    "progressStart",
    "progressStep",
    "progressEnd",
    "pause",
    "stop",
    "destroy",
    "play",
    "from",
    "to",
    "fromTo",
    "onFinish"
  ];
  for (const key in currentProps) {
    if (currentProps.hasOwnProperty(key) && !reservedProps.includes(key) && currentProps[key] !== prevProps[key]) {
      animation[key](currentProps[key]);
    }
  }
  const fromValues = currentProps.from;
  if (fromValues && fromValues !== prevProps.from) {
    const values = Array.isArray(fromValues) ? fromValues : [fromValues];
    values.forEach((val) => animation.from(val.property, val.value));
  }
  const toValues = currentProps.to;
  if (toValues && toValues !== prevProps.to) {
    const values = Array.isArray(toValues) ? toValues : [toValues];
    values.forEach((val) => animation.to(val.property, val.value));
  }
  const fromToValues = currentProps.fromTo;
  if (fromToValues && fromToValues !== prevProps.fromTo) {
    const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];
    values.forEach((val) => animation.fromTo(val.property, val.fromValue, val.toValue));
  }
  const onFinishValues = currentProps.onFinish;
  if (onFinishValues && onFinishValues !== prevProps.onFinish) {
    const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];
    values.forEach((val) => animation.onFinish(val.callback, val.opts));
  }
};
var checkProgress = (animation, currentProps = {}, prevProps = {}) => {
  var _a, _b, _c, _d, _e;
  const { progressStart, progressStep, progressEnd } = currentProps;
  if (progressStart && (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) || ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {
    animation.progressStart(progressStart.forceLinearEasing, progressStart.step);
  }
  if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {
    animation.progressStep(progressStep.step);
  }
  if (progressEnd && (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) || ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {
    animation.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);
  }
};
var checkPlayback = (animation, currentProps = {}, prevProps = {}) => {
  if (!prevProps.play && currentProps.play) {
    animation.play();
  }
  if (!prevProps.pause && currentProps.pause) {
    animation.pause();
  }
  if (!prevProps.stop && currentProps.stop) {
    animation.stop();
  }
  if (!prevProps.destroy && currentProps.destroy) {
    animation.destroy();
  }
};
function useController(displayName, controller) {
  const overlayRef = (0, import_react.useRef)();
  const didDismissEventName = (0, import_react.useMemo)(() => `on${displayName}DidDismiss`, [displayName]);
  const didPresentEventName = (0, import_react.useMemo)(() => `on${displayName}DidPresent`, [displayName]);
  const willDismissEventName = (0, import_react.useMemo)(() => `on${displayName}WillDismiss`, [displayName]);
  const willPresentEventName = (0, import_react.useMemo)(() => `on${displayName}WillPresent`, [displayName]);
  const present = async (options) => {
    if (overlayRef.current) {
      return;
    }
    const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
    const handleDismiss = (event) => {
      if (onDidDismiss) {
        onDidDismiss(event);
      }
      overlayRef.current = void 0;
    };
    overlayRef.current = await controller.create(Object.assign({}, rest));
    attachProps(overlayRef.current, {
      [didDismissEventName]: handleDismiss,
      [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),
      [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),
      [willPresentEventName]: (e) => onWillPresent && onWillPresent(e)
    });
    overlayRef.current.present();
  };
  const dismiss = async () => {
    overlayRef.current && await overlayRef.current.dismiss();
    overlayRef.current = void 0;
  };
  return {
    present,
    dismiss
  };
}
function useIonActionSheet() {
  const controller = useController("IonActionSheet", actionSheetController);
  function present(buttonsOrOptions, header) {
    if (Array.isArray(buttonsOrOptions)) {
      controller.present({
        buttons: buttonsOrOptions,
        header
      });
    } else {
      controller.present(buttonsOrOptions);
    }
  }
  return [
    present,
    controller.dismiss
  ];
}
function useIonAlert() {
  const controller = useController("IonAlert", alertController);
  function present(messageOrOptions, buttons) {
    if (typeof messageOrOptions === "string") {
      controller.present({
        message: messageOrOptions,
        buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: "Ok" }]
      });
    } else {
      controller.present(messageOrOptions);
    }
  }
  return [
    present,
    controller.dismiss
  ];
}
function useIonToast() {
  const controller = useController("IonToast", toastController);
  function present(messageOrOptions, duration) {
    if (typeof messageOrOptions === "string") {
      controller.present({
        message: messageOrOptions,
        duration
      });
    } else {
      controller.present(messageOrOptions);
    }
  }
  return [
    present,
    controller.dismiss
  ];
}
function useOverlay(displayName, controller, component, componentProps) {
  const overlayRef = (0, import_react.useRef)();
  const containerElRef = (0, import_react.useRef)();
  const didDismissEventName = (0, import_react.useMemo)(() => `on${displayName}DidDismiss`, [displayName]);
  const didPresentEventName = (0, import_react.useMemo)(() => `on${displayName}DidPresent`, [displayName]);
  const willDismissEventName = (0, import_react.useMemo)(() => `on${displayName}WillDismiss`, [displayName]);
  const willPresentEventName = (0, import_react.useMemo)(() => `on${displayName}WillPresent`, [displayName]);
  const [isOpen, setIsOpen] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    if (isOpen && component && containerElRef.current) {
      if (import_react.default.isValidElement(component)) {
        import_react_dom.default.render(component, containerElRef.current);
      } else {
        import_react_dom.default.render(import_react.default.createElement(component, componentProps), containerElRef.current);
      }
    }
  }, [component, containerElRef.current, isOpen, componentProps]);
  const present = async (options) => {
    if (overlayRef.current) {
      return;
    }
    const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
    if (typeof document !== "undefined") {
      containerElRef.current = document.createElement("div");
    }
    overlayRef.current = await controller.create(Object.assign(Object.assign({}, rest), { component: containerElRef.current }));
    attachProps(overlayRef.current, {
      [didDismissEventName]: handleDismiss,
      [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),
      [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),
      [willPresentEventName]: (e) => onWillPresent && onWillPresent(e)
    });
    overlayRef.current.present();
    setIsOpen(true);
    function handleDismiss(event) {
      if (onDidDismiss) {
        onDidDismiss(event);
      }
      overlayRef.current = void 0;
      containerElRef.current = void 0;
      setIsOpen(false);
    }
  };
  const dismiss = async () => {
    overlayRef.current && await overlayRef.current.dismiss();
    overlayRef.current = void 0;
    containerElRef.current = void 0;
  };
  return {
    present,
    dismiss
  };
}
function useIonModal(component, componentProps) {
  const controller = useOverlay("IonModal", modalController, component, componentProps);
  function present(options = {}) {
    controller.present(options);
  }
  return [
    present,
    controller.dismiss
  ];
}
function useIonPopover(component, componentProps) {
  const controller = useOverlay("IonPopover", popoverController, component, componentProps);
  function present(options = {}) {
    controller.present(options);
  }
  return [
    present,
    controller.dismiss
  ];
}
function useIonPicker() {
  const controller = useController("IonPicker", pickerController);
  function present(columnsOrOptions, buttons) {
    if (Array.isArray(columnsOrOptions)) {
      controller.present({
        columns: columnsOrOptions,
        buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: "Ok" }]
      });
    } else {
      controller.present(columnsOrOptions);
    }
  }
  return [present, controller.dismiss];
}
function useIonLoading() {
  const controller = useController("IonLoading", loadingController);
  function present(messageOrOptions = "", duration, spinner) {
    if (typeof messageOrOptions === "string") {
      controller.present({
        message: messageOrOptions,
        duration,
        spinner: spinner !== null && spinner !== void 0 ? spinner : "lines"
      });
    } else {
      controller.present(messageOrOptions);
    }
  }
  return [present, controller.dismiss];
}
addIcons({
  "arrow-back-sharp": arrowBackSharp,
  "caret-back-sharp": caretBackSharp,
  "chevron-back": chevronBack,
  "chevron-forward": chevronForward,
  close,
  "close-circle": closeCircle,
  "close-sharp": closeSharp,
  "menu-outline": menuOutline,
  "menu-sharp": menuSharp,
  "reorder-two-sharp": reorderTwoSharp,
  "reorder-three-outline": reorderThreeOutline,
  "search-outline": searchOutline,
  "search-sharp": searchSharp
});
if (typeof window !== "undefined") {
  defineCustomElements(window);
}
var RouteManagerContext = import_react.default.createContext({
  addViewItem: () => void 0,
  canGoBack: () => void 0,
  clearOutlet: () => void 0,
  createViewItem: () => void 0,
  findViewItemByPathname: () => void 0,
  findLeavingViewItemByRouteInfo: () => void 0,
  findViewItemByRouteInfo: () => void 0,
  getChildrenToRender: () => void 0,
  goBack: () => void 0,
  unMountViewItem: () => void 0
});
var ViewLifeCycleManager = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
    this._isMounted = false;
    this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
      if (!this.props.mount) {
        if (this._isMounted) {
          this.setState({
            show: false
          }, () => this.props.removeView());
        }
      }
    });
    this.state = {
      show: true
    };
  }
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
  render() {
    const { show } = this.state;
    return import_react.default.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children);
  }
};
var LocationHistory = class {
  constructor() {
    this.locationHistory = [];
    this.tabHistory = {};
  }
  add(routeInfo) {
    if (routeInfo.routeAction === "push" || routeInfo.routeAction == null) {
      this._add(routeInfo);
    } else if (routeInfo.routeAction === "pop") {
      this._pop(routeInfo);
    } else if (routeInfo.routeAction === "replace") {
      this._replace(routeInfo);
    }
    if (routeInfo.routeDirection === "root") {
      this._clear();
      this._add(routeInfo);
    }
  }
  clearTabStack(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      routeInfos.forEach((ri) => {
        this.locationHistory = this.locationHistory.filter((x) => x.id !== ri.id);
      });
      this.tabHistory[tab] = [];
    }
  }
  update(routeInfo) {
    const locationIndex = this.locationHistory.findIndex((x) => x.id === routeInfo.id);
    if (locationIndex > -1) {
      this.locationHistory.splice(locationIndex, 1, routeInfo);
    }
    const tabArray = this.tabHistory[routeInfo.tab || ""];
    if (tabArray) {
      const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);
      if (tabIndex > -1) {
        tabArray.splice(tabIndex, 1, routeInfo);
      } else {
        tabArray.push(routeInfo);
      }
    } else if (routeInfo.tab) {
      this.tabHistory[routeInfo.tab] = [routeInfo];
    }
  }
  _add(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {
        routeInfos.pop();
      }
      routeInfos.push(routeInfo);
    }
    this.locationHistory.push(routeInfo);
  }
  _areRoutesEqual(route1, route2) {
    if (!route1 || !route2) {
      return false;
    }
    return route1.pathname === route2.pathname && route1.search === route2.search;
  }
  _pop(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      routeInfos.pop();
      routeInfos.pop();
      routeInfos.push(routeInfo);
    }
    this.locationHistory.pop();
    this.locationHistory.pop();
    this.locationHistory.push(routeInfo);
  }
  _replace(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    routeInfos && routeInfos.pop();
    this.locationHistory.pop();
    this._add(routeInfo);
  }
  _clear() {
    const keys = Object.keys(this.tabHistory);
    keys.forEach((k) => this.tabHistory[k] = []);
    this.locationHistory = [];
  }
  _getRouteInfosByKey(key) {
    let routeInfos;
    if (key) {
      routeInfos = this.tabHistory[key];
      if (!routeInfos) {
        routeInfos = this.tabHistory[key] = [];
      }
    }
    return routeInfos;
  }
  getFirstRouteInfoForTab(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      return routeInfos[0];
    }
    return void 0;
  }
  getCurrentRouteInfoForTab(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      return routeInfos[routeInfos.length - 1];
    }
    return void 0;
  }
  findLastLocation(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      for (let i = routeInfos.length - 2; i >= 0; i--) {
        const ri = routeInfos[i];
        if (ri) {
          if (ri.pathname === routeInfo.pushedByRoute) {
            return ri;
          }
        }
      }
    }
    for (let i = this.locationHistory.length - 2; i >= 0; i--) {
      const ri = this.locationHistory[i];
      if (ri) {
        if (ri.pathname === routeInfo.pushedByRoute) {
          return ri;
        }
      }
    }
    return void 0;
  }
  previous() {
    return this.locationHistory[this.locationHistory.length - 2] || this.locationHistory[this.locationHistory.length - 1];
  }
  current() {
    return this.locationHistory[this.locationHistory.length - 1];
  }
  canGoBack() {
    return this.locationHistory.length > 1;
  }
};
var NavManager = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this._isMounted = false;
    this.ionRouterContextValue = {
      push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {
        this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);
      },
      back: (animationBuilder) => {
        this.goBack(void 0, animationBuilder);
      },
      canGoBack: () => this.props.locationHistory.canGoBack(),
      nativeBack: () => this.props.onNativeBack(),
      routeInfo: this.props.routeInfo
    };
    this.state = {
      goBack: this.goBack.bind(this),
      hasIonicRouter: () => true,
      navigate: this.navigate.bind(this),
      getIonRedirect: this.getIonRedirect.bind(this),
      getIonRoute: this.getIonRoute.bind(this),
      getStackManager: this.getStackManager.bind(this),
      getPageManager: this.getPageManager.bind(this),
      routeInfo: this.props.routeInfo,
      setCurrentTab: this.props.onSetCurrentTab,
      changeTab: this.props.onChangeTab,
      resetTab: this.props.onResetTab
    };
    if (typeof document !== "undefined") {
      this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);
      document.addEventListener("ionBackButton", this.handleHardwareBackButton);
    }
  }
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    if (typeof document !== "undefined") {
      document.removeEventListener("ionBackButton", this.handleHardwareBackButton);
      this._isMounted = false;
    }
  }
  handleHardwareBackButton(e) {
    e.detail.register(0, (processNextHandler) => {
      if (this._isMounted) {
        this.nativeGoBack();
        processNextHandler();
      }
    });
  }
  goBack(route, animationBuilder) {
    this.props.onNavigateBack(route, animationBuilder);
  }
  nativeGoBack() {
    this.props.onNativeBack();
  }
  navigate(path, direction = "forward", action = "push", animationBuilder, options, tab) {
    this.props.onNavigate(path, action, direction, animationBuilder, options, tab);
  }
  getPageManager() {
    return PageManager;
  }
  getIonRedirect() {
    return this.props.ionRedirect;
  }
  getIonRoute() {
    return this.props.ionRoute;
  }
  getStackManager() {
    return this.props.stackManager;
  }
  render() {
    return import_react.default.createElement(NavContext.Provider, { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) }, import_react.default.createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children));
  }
};
var ViewStacks = class {
  constructor() {
    this.viewStacks = {};
    this.add = this.add.bind(this);
    this.clear = this.clear.bind(this);
    this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);
    this.remove = this.remove.bind(this);
  }
  add(viewItem) {
    const { outletId } = viewItem;
    if (!this.viewStacks[outletId]) {
      this.viewStacks[outletId] = [viewItem];
    } else {
      this.viewStacks[outletId].push(viewItem);
    }
  }
  clear(outletId) {
    setTimeout(() => {
      delete this.viewStacks[outletId];
    }, 500);
  }
  getViewItemsForOutlet(outletId) {
    return this.viewStacks[outletId] || [];
  }
  remove(viewItem) {
    const { outletId } = viewItem;
    const viewStack = this.viewStacks[outletId];
    if (viewStack) {
      const viewItemToRemove = viewStack.find((x) => x.id === viewItem.id);
      if (viewItemToRemove) {
        viewItemToRemove.mount = false;
        this.viewStacks[outletId] = viewStack.filter((x) => x.id !== viewItemToRemove.id);
      }
    }
  }
  getStackIds() {
    return Object.keys(this.viewStacks);
  }
  getAllViewItems() {
    const keys = this.getStackIds();
    const viewItems = [];
    keys.forEach((k) => {
      viewItems.push(...this.viewStacks[k]);
    });
    return viewItems;
  }
};
var ids = { main: 0 };
var generateId = (type = "main") => {
  var _a;
  const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
  ids[type] = id;
  return id.toString();
};
export {
  CreateAnimation,
  DefaultIonLifeCycleContext,
  IonActionSheet,
  IonAlert,
  IonApp,
  IonAvatar,
  IonBackButton,
  IonBackdrop,
  IonBadge,
  IonButton,
  IonButtons,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardSubtitle,
  IonCardTitle,
  IonCheckbox,
  IonChip,
  IonCol,
  IonContent,
  IonDatetime,
  IonFab,
  IonFabButton,
  IonFabList,
  IonFooter,
  IonGrid,
  IonHeader,
  IonIcon,
  IonImg,
  IonInfiniteScroll,
  IonInfiniteScrollContent,
  IonInput,
  IonItem,
  IonItemDivider,
  IonItemGroup,
  IonItemOption,
  IonItemOptions,
  IonItemSliding,
  IonLabel,
  IonLifeCycleContext,
  IonList,
  IonListHeader,
  IonLoading,
  IonMenu,
  IonMenuButton,
  IonMenuToggle,
  IonModal,
  IonNav,
  IonNote,
  IonPage,
  IonPicker,
  IonPickerColumn,
  IonPopover,
  IonProgressBar,
  IonRadio,
  IonRadioGroup,
  IonRange,
  IonRedirect,
  IonRefresher,
  IonRefresherContent,
  IonReorder,
  IonReorderGroup,
  IonRippleEffect,
  IonRoute,
  IonRouterContext,
  IonRouterLink,
  IonRouterOutlet,
  IonRow,
  IonSearchbar,
  IonSegment,
  IonSegmentButton,
  IonSelect,
  IonSelectOption,
  IonSelectPopover,
  IonSkeletonText,
  IonSlide,
  IonSlides,
  IonSpinner,
  IonSplitPane,
  IonTab,
  IonTabBar,
  IonTabButton,
  IonTabs,
  IonTabsContext,
  IonText,
  IonTextarea,
  IonThumbnail,
  IonTitle,
  IonToast,
  IonToggle,
  IonToolbar,
  IonVirtualScroll,
  IonicSafeString,
  LocationHistory,
  NavContext,
  NavManager,
  RouteManagerContext,
  StackContext,
  ViewLifeCycleManager,
  ViewStacks,
  createAnimation,
  createGesture,
  generateId,
  getConfig,
  getPlatforms2 as getPlatforms,
  iosTransitionAnimation,
  isPlatform2 as isPlatform,
  mdTransitionAnimation,
  setupConfig,
  useIonActionSheet,
  useIonAlert,
  useIonLoading,
  useIonModal,
  useIonPicker,
  useIonPopover,
  useIonRouter,
  useIonToast,
  useIonViewDidEnter,
  useIonViewDidLeave,
  useIonViewWillEnter,
  useIonViewWillLeave,
  withIonLifeCycle
};
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
//# sourceMappingURL=@ionic_react.js.map
