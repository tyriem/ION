import {
  Route,
  Router,
  createBrowserHistory,
  createHashHistory,
  history_exports,
  init_history,
  init_react_router,
  init_tiny_invariant_esm,
  init_tiny_warning_esm,
  matchPath,
  react_router_exports,
  require_prop_types,
  tiny_invariant_esm_exports,
  tiny_warning_esm_exports
} from "./chunk-AFM7GNIU.js";
import {
  dist_exports,
  dist_exports2,
  icons_exports,
  init_dist,
  init_dist2,
  init_icons,
  init_loader,
  loader_exports
} from "./chunk-F6YEIAHG.js";
import "./chunk-4674Q6F5.js";
import "./chunk-JSO227FL.js";
import "./chunk-FFQUAV47.js";
import {
  require_react_dom
} from "./chunk-DRKKF5W5.js";
import {
  require_react
} from "./chunk-NZVPNYPO.js";
import {
  __rest,
  init_tslib_es6,
  tslib_es6_exports
} from "./chunk-2TEGCL4A.js";
import {
  __commonJS,
  __toModule,
  define_process_env_default,
  init_define_process_env
} from "./chunk-ZU54QAZD.js";

// ../../../../../Documents/CODE/ION/ION 1 - HelloWorld/node_modules/react-router-dom/cjs/react-router-dom.js
var require_react_router_dom = __commonJS({
  "../../../../../Documents/CODE/ION/ION 1 - HelloWorld/node_modules/react-router-dom/cjs/react-router-dom.js"(exports) {
    init_define_process_env();
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var reactRouter = (init_react_router(), react_router_exports);
    var React2 = _interopDefault(require_react());
    var history = (init_history(), history_exports);
    var PropTypes = _interopDefault(require_prop_types());
    var warning = _interopDefault((init_tiny_warning_esm(), tiny_warning_esm_exports));
    var invariant = _interopDefault((init_tiny_invariant_esm(), tiny_invariant_esm_exports));
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var BrowserRouter = function(_React$Component) {
      _inheritsLoose(BrowserRouter2, _React$Component);
      function BrowserRouter2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.history = history.createBrowserHistory(_this.props);
        return _this;
      }
      var _proto = BrowserRouter2.prototype;
      _proto.render = function render() {
        return React2.createElement(reactRouter.Router, {
          history: this.history,
          children: this.props.children
        });
      };
      return BrowserRouter2;
    }(React2.Component);
    {
      BrowserRouter.propTypes = {
        basename: PropTypes.string,
        children: PropTypes.node,
        forceRefresh: PropTypes.bool,
        getUserConfirmation: PropTypes.func,
        keyLength: PropTypes.number
      };
      BrowserRouter.prototype.componentDidMount = function() {
        warning(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.");
      };
    }
    var HashRouter = function(_React$Component) {
      _inheritsLoose(HashRouter2, _React$Component);
      function HashRouter2() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.history = history.createHashHistory(_this.props);
        return _this;
      }
      var _proto = HashRouter2.prototype;
      _proto.render = function render() {
        return React2.createElement(reactRouter.Router, {
          history: this.history,
          children: this.props.children
        });
      };
      return HashRouter2;
    }(React2.Component);
    {
      HashRouter.propTypes = {
        basename: PropTypes.string,
        children: PropTypes.node,
        getUserConfirmation: PropTypes.func,
        hashType: PropTypes.oneOf(["hashbang", "noslash", "slash"])
      };
      HashRouter.prototype.componentDidMount = function() {
        warning(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.");
      };
    }
    var resolveToLocation = function resolveToLocation2(to, currentLocation) {
      return typeof to === "function" ? to(currentLocation) : to;
    };
    var normalizeToLocation = function normalizeToLocation2(to, currentLocation) {
      return typeof to === "string" ? history.createLocation(to, null, null, currentLocation) : to;
    };
    var forwardRefShim = function forwardRefShim2(C) {
      return C;
    };
    var forwardRef = React2.forwardRef;
    if (typeof forwardRef === "undefined") {
      forwardRef = forwardRefShim;
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    var LinkAnchor = forwardRef(function(_ref, forwardedRef) {
      var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);
      var target = rest.target;
      var props = _extends({}, rest, {
        onClick: function onClick(event) {
          try {
            if (_onClick)
              _onClick(event);
          } catch (ex) {
            event.preventDefault();
            throw ex;
          }
          if (!event.defaultPrevented && event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
            event.preventDefault();
            navigate();
          }
        }
      });
      if (forwardRefShim !== forwardRef) {
        props.ref = forwardedRef || innerRef;
      } else {
        props.ref = innerRef;
      }
      return React2.createElement("a", props);
    });
    {
      LinkAnchor.displayName = "LinkAnchor";
    }
    var Link = forwardRef(function(_ref2, forwardedRef) {
      var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);
      return React2.createElement(reactRouter.__RouterContext.Consumer, null, function(context) {
        !context ? invariant(false, "You should not use <Link> outside a <Router>") : void 0;
        var history2 = context.history;
        var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);
        var href = location ? history2.createHref(location) : "";
        var props = _extends({}, rest, {
          href,
          navigate: function navigate() {
            var location2 = resolveToLocation(to, context.location);
            var method = replace ? history2.replace : history2.push;
            method(location2);
          }
        });
        if (forwardRefShim !== forwardRef) {
          props.ref = forwardedRef || innerRef;
        } else {
          props.innerRef = innerRef;
        }
        return React2.createElement(component, props);
      });
    });
    {
      toType = PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.func]);
      refType = PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.shape({
        current: PropTypes.any
      })]);
      Link.displayName = "Link";
      Link.propTypes = {
        innerRef: refType,
        onClick: PropTypes.func,
        replace: PropTypes.bool,
        target: PropTypes.string,
        to: toType.isRequired
      };
    }
    var toType;
    var refType;
    var forwardRefShim$1 = function forwardRefShim2(C) {
      return C;
    };
    var forwardRef$1 = React2.forwardRef;
    if (typeof forwardRef$1 === "undefined") {
      forwardRef$1 = forwardRefShim$1;
    }
    function joinClassnames() {
      for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
        classnames[_key] = arguments[_key];
      }
      return classnames.filter(function(i) {
        return i;
      }).join(" ");
    }
    var NavLink = forwardRef$1(function(_ref, forwardedRef) {
      var _ref$ariaCurrent = _ref["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to = _ref.to, innerRef = _ref.innerRef, rest = _objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
      return React2.createElement(reactRouter.__RouterContext.Consumer, null, function(context) {
        !context ? invariant(false, "You should not use <NavLink> outside a <Router>") : void 0;
        var currentLocation = locationProp || context.location;
        var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
        var path = toLocation.pathname;
        var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
        var match = escapedPath ? reactRouter.matchPath(currentLocation.pathname, {
          path: escapedPath,
          exact,
          sensitive,
          strict
        }) : null;
        var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
        var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
        var style = isActive ? _extends({}, styleProp, {}, activeStyle) : styleProp;
        var props = _extends({
          "aria-current": isActive && ariaCurrent || null,
          className,
          style,
          to: toLocation
        }, rest);
        if (forwardRefShim$1 !== forwardRef$1) {
          props.ref = forwardedRef || innerRef;
        } else {
          props.innerRef = innerRef;
        }
        return React2.createElement(Link, props);
      });
    });
    {
      NavLink.displayName = "NavLink";
      ariaCurrentType = PropTypes.oneOf(["page", "step", "location", "date", "time", "true"]);
      NavLink.propTypes = _extends({}, Link.propTypes, {
        "aria-current": ariaCurrentType,
        activeClassName: PropTypes.string,
        activeStyle: PropTypes.object,
        className: PropTypes.string,
        exact: PropTypes.bool,
        isActive: PropTypes.func,
        location: PropTypes.object,
        sensitive: PropTypes.bool,
        strict: PropTypes.bool,
        style: PropTypes.object
      });
    }
    var ariaCurrentType;
    Object.defineProperty(exports, "MemoryRouter", {
      enumerable: true,
      get: function() {
        return reactRouter.MemoryRouter;
      }
    });
    Object.defineProperty(exports, "Prompt", {
      enumerable: true,
      get: function() {
        return reactRouter.Prompt;
      }
    });
    Object.defineProperty(exports, "Redirect", {
      enumerable: true,
      get: function() {
        return reactRouter.Redirect;
      }
    });
    Object.defineProperty(exports, "Route", {
      enumerable: true,
      get: function() {
        return reactRouter.Route;
      }
    });
    Object.defineProperty(exports, "Router", {
      enumerable: true,
      get: function() {
        return reactRouter.Router;
      }
    });
    Object.defineProperty(exports, "StaticRouter", {
      enumerable: true,
      get: function() {
        return reactRouter.StaticRouter;
      }
    });
    Object.defineProperty(exports, "Switch", {
      enumerable: true,
      get: function() {
        return reactRouter.Switch;
      }
    });
    Object.defineProperty(exports, "generatePath", {
      enumerable: true,
      get: function() {
        return reactRouter.generatePath;
      }
    });
    Object.defineProperty(exports, "matchPath", {
      enumerable: true,
      get: function() {
        return reactRouter.matchPath;
      }
    });
    Object.defineProperty(exports, "useHistory", {
      enumerable: true,
      get: function() {
        return reactRouter.useHistory;
      }
    });
    Object.defineProperty(exports, "useLocation", {
      enumerable: true,
      get: function() {
        return reactRouter.useLocation;
      }
    });
    Object.defineProperty(exports, "useParams", {
      enumerable: true,
      get: function() {
        return reactRouter.useParams;
      }
    });
    Object.defineProperty(exports, "useRouteMatch", {
      enumerable: true,
      get: function() {
        return reactRouter.useRouteMatch;
      }
    });
    Object.defineProperty(exports, "withRouter", {
      enumerable: true,
      get: function() {
        return reactRouter.withRouter;
      }
    });
    exports.BrowserRouter = BrowserRouter;
    exports.HashRouter = HashRouter;
    exports.Link = Link;
    exports.NavLink = NavLink;
  }
});

// ../../../../../Documents/CODE/ION/ION 1 - HelloWorld/node_modules/react-router-dom/index.js
var require_react_router_dom2 = __commonJS({
  "../../../../../Documents/CODE/ION/ION 1 - HelloWorld/node_modules/react-router-dom/index.js"(exports, module) {
    init_define_process_env();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_router_dom();
    }
  }
});

// ../../../../../Documents/CODE/ION/ION 1 - HelloWorld/node_modules/@ionic/react/dist/index.js
var require_dist = __commonJS({
  "../../../../../Documents/CODE/ION/ION 1 - HelloWorld/node_modules/@ionic/react/dist/index.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React2 = require_react();
    var loader = (init_loader(), loader_exports);
    var ionicons = (init_dist(), dist_exports);
    var icons = (init_icons(), icons_exports);
    var core = (init_dist2(), dist_exports2);
    var tslib = (init_tslib_es6(), tslib_es6_exports);
    var ReactDOM = require_react_dom();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React2);
    var ReactDOM__default = _interopDefaultLegacy(ReactDOM);
    var IonLifeCycleContext = React__default["default"].createContext({
      onIonViewWillEnter: () => {
        return;
      },
      ionViewWillEnter: () => {
        return;
      },
      onIonViewDidEnter: () => {
        return;
      },
      ionViewDidEnter: () => {
        return;
      },
      onIonViewWillLeave: () => {
        return;
      },
      ionViewWillLeave: () => {
        return;
      },
      onIonViewDidLeave: () => {
        return;
      },
      ionViewDidLeave: () => {
        return;
      }
    });
    var DefaultIonLifeCycleContext = class {
      constructor() {
        this.ionViewWillEnterCallbacks = [];
        this.ionViewDidEnterCallbacks = [];
        this.ionViewWillLeaveCallbacks = [];
        this.ionViewDidLeaveCallbacks = [];
      }
      onIonViewWillEnter(callback) {
        if (callback.id) {
          const index = this.ionViewWillEnterCallbacks.findIndex((x) => x.id === callback.id);
          if (index > -1) {
            this.ionViewWillEnterCallbacks[index] = callback;
          } else {
            this.ionViewWillEnterCallbacks.push(callback);
          }
        } else {
          this.ionViewWillEnterCallbacks.push(callback);
        }
      }
      ionViewWillEnter() {
        this.ionViewWillEnterCallbacks.forEach((cb) => cb());
      }
      onIonViewDidEnter(callback) {
        if (callback.id) {
          const index = this.ionViewDidEnterCallbacks.findIndex((x) => x.id === callback.id);
          if (index > -1) {
            this.ionViewDidEnterCallbacks[index] = callback;
          } else {
            this.ionViewDidEnterCallbacks.push(callback);
          }
        } else {
          this.ionViewDidEnterCallbacks.push(callback);
        }
      }
      ionViewDidEnter() {
        this.ionViewDidEnterCallbacks.forEach((cb) => cb());
      }
      onIonViewWillLeave(callback) {
        if (callback.id) {
          const index = this.ionViewWillLeaveCallbacks.findIndex((x) => x.id === callback.id);
          if (index > -1) {
            this.ionViewWillLeaveCallbacks[index] = callback;
          } else {
            this.ionViewWillLeaveCallbacks.push(callback);
          }
        } else {
          this.ionViewWillLeaveCallbacks.push(callback);
        }
      }
      ionViewWillLeave() {
        this.ionViewWillLeaveCallbacks.forEach((cb) => cb());
      }
      onIonViewDidLeave(callback) {
        if (callback.id) {
          const index = this.ionViewDidLeaveCallbacks.findIndex((x) => x.id === callback.id);
          if (index > -1) {
            this.ionViewDidLeaveCallbacks[index] = callback;
          } else {
            this.ionViewDidLeaveCallbacks.push(callback);
          }
        } else {
          this.ionViewDidLeaveCallbacks.push(callback);
        }
      }
      ionViewDidLeave() {
        this.ionViewDidLeaveCallbacks.forEach((cb) => cb());
        this.componentCanBeDestroyed();
      }
      onComponentCanBeDestroyed(callback) {
        this.componentCanBeDestroyedCallback = callback;
      }
      componentCanBeDestroyed() {
        if (this.componentCanBeDestroyedCallback) {
          this.componentCanBeDestroyedCallback();
        }
      }
    };
    var withIonLifeCycle = (WrappedComponent) => {
      return class IonLifeCycle extends React__default["default"].Component {
        constructor(props) {
          super(props);
          this.componentRef = React__default["default"].createRef();
        }
        componentDidMount() {
          const element = this.componentRef.current;
          this.context.onIonViewWillEnter(() => {
            if (element && element.ionViewWillEnter) {
              element.ionViewWillEnter();
            }
          });
          this.context.onIonViewDidEnter(() => {
            if (element && element.ionViewDidEnter) {
              element.ionViewDidEnter();
            }
          });
          this.context.onIonViewWillLeave(() => {
            if (element && element.ionViewWillLeave) {
              element.ionViewWillLeave();
            }
          });
          this.context.onIonViewDidLeave(() => {
            if (element && element.ionViewDidLeave) {
              element.ionViewDidLeave();
            }
          });
        }
        render() {
          return React__default["default"].createElement(IonLifeCycleContext.Consumer, null, (context) => {
            this.context = context;
            return React__default["default"].createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props));
          });
        }
      };
    };
    var useIonViewWillEnter = (callback, deps = []) => {
      const context = React2.useContext(IonLifeCycleContext);
      const id = React2.useRef();
      id.current = id.current || Math.floor(Math.random() * 1e6);
      React2.useEffect(() => {
        callback.id = id.current;
        context.onIonViewWillEnter(callback);
      }, deps);
    };
    var useIonViewDidEnter = (callback, deps = []) => {
      const context = React2.useContext(IonLifeCycleContext);
      const id = React2.useRef();
      id.current = id.current || Math.floor(Math.random() * 1e6);
      React2.useEffect(() => {
        callback.id = id.current;
        context.onIonViewDidEnter(callback);
      }, deps);
    };
    var useIonViewWillLeave = (callback, deps = []) => {
      const context = React2.useContext(IonLifeCycleContext);
      const id = React2.useRef();
      id.current = id.current || Math.floor(Math.random() * 1e6);
      React2.useEffect(() => {
        callback.id = id.current;
        context.onIonViewWillLeave(callback);
      }, deps);
    };
    var useIonViewDidLeave = (callback, deps = []) => {
      const context = React2.useContext(IonLifeCycleContext);
      const id = React2.useRef();
      id.current = id.current || Math.floor(Math.random() * 1e6);
      React2.useEffect(() => {
        callback.id = id.current;
        context.onIonViewDidLeave(callback);
      }, deps);
    };
    var NavContext = React__default["default"].createContext({
      getIonRedirect: () => void 0,
      getIonRoute: () => void 0,
      getPageManager: () => void 0,
      getStackManager: () => void 0,
      goBack: (route) => {
        if (typeof window !== "undefined") {
          if (typeof route === "string") {
            window.location.pathname = route;
          } else {
            window.history.back();
          }
        }
      },
      navigate: (path) => {
        if (typeof window !== "undefined") {
          window.location.pathname = path;
        }
      },
      hasIonicRouter: () => false,
      routeInfo: void 0,
      setCurrentTab: () => void 0,
      changeTab: (_tab, path) => {
        if (typeof window !== "undefined") {
          window.location.pathname = path;
        }
      },
      resetTab: (_tab, path) => {
        if (typeof window !== "undefined") {
          window.location.pathname = path;
        }
      }
    });
    var dashToPascalCase = (str) => str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
    var camelToDashCase = (str) => str.replace(/([A-Z])/g, (m) => `-${m[0].toLowerCase()}`);
    var attachProps = (node, newProps, oldProps = {}) => {
      if (node instanceof Element) {
        const className = getClassName(node.classList, newProps, oldProps);
        if (className !== "") {
          node.className = className;
        }
        Object.keys(newProps).forEach((name) => {
          if (name === "children" || name === "style" || name === "ref" || name === "class" || name === "className" || name === "forwardedRef") {
            return;
          }
          if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
            const eventName = name.substring(2);
            const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
            if (!isCoveredByReact(eventNameLc)) {
              syncEvent(node, eventNameLc, newProps[name]);
            }
          } else {
            const propType = typeof newProps[name];
            if (propType === "string") {
              node.setAttribute(camelToDashCase(name), newProps[name]);
            } else {
              node[name] = newProps[name];
            }
          }
        });
      }
    };
    var getClassName = (classList, newProps, oldProps) => {
      const newClassProp = newProps.className || newProps.class;
      const oldClassProp = oldProps.className || oldProps.class;
      const currentClasses = arrayToMap(classList);
      const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(" ") : []);
      const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(" ") : []);
      const finalClassNames = [];
      currentClasses.forEach((currentClass) => {
        if (incomingPropClasses.has(currentClass)) {
          finalClassNames.push(currentClass);
          incomingPropClasses.delete(currentClass);
        } else if (!oldPropClasses.has(currentClass)) {
          finalClassNames.push(currentClass);
        }
      });
      incomingPropClasses.forEach((s) => finalClassNames.push(s));
      return finalClassNames.join(" ");
    };
    var isCoveredByReact = (eventNameSuffix) => {
      if (typeof document === "undefined") {
        return true;
      } else {
        const eventName = "on" + eventNameSuffix;
        let isSupported = eventName in document;
        if (!isSupported) {
          const element = document.createElement("div");
          element.setAttribute(eventName, "return;");
          isSupported = typeof element[eventName] === "function";
        }
        return isSupported;
      }
    };
    var syncEvent = (node, eventName, newEventHandler) => {
      const eventStore = node.__events || (node.__events = {});
      const oldEventHandler = eventStore[eventName];
      if (oldEventHandler) {
        node.removeEventListener(eventName, oldEventHandler);
      }
      node.addEventListener(eventName, eventStore[eventName] = function handler(e) {
        if (newEventHandler) {
          newEventHandler.call(this, e);
        }
      });
    };
    var arrayToMap = (arr) => {
      const map = new Map();
      arr.forEach((s) => map.set(s, s));
      return map;
    };
    var createForwardRef = (ReactComponent, displayName) => {
      const forwardRef = (props, ref) => {
        return React__default["default"].createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
      };
      forwardRef.displayName = displayName;
      return React__default["default"].forwardRef(forwardRef);
    };
    var setRef = (ref, value) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    };
    var mergeRefs = (...refs) => {
      return (value) => {
        refs.forEach((ref) => {
          setRef(ref, value);
        });
      };
    };
    var isPlatform = (platform) => {
      return core.isPlatform(window, platform);
    };
    var getPlatforms = () => {
      return core.getPlatforms(window);
    };
    var getConfig2 = () => {
      if (typeof window !== "undefined") {
        const Ionic = window.Ionic;
        if (Ionic && Ionic.config) {
          return Ionic.config;
        }
      }
      return null;
    };
    var createReactComponent = (tagName, routerLinkComponent = false) => {
      const displayName = dashToPascalCase(tagName);
      const ReactComponent = class extends React__default["default"].Component {
        constructor(props) {
          super(props);
          this.handleClick = (e) => {
            const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;
            if (routerLink !== void 0) {
              e.preventDefault();
              this.context.navigate(routerLink, routerDirection, void 0, routerAnimation, routerOptions);
            }
          };
          this.ref = React__default["default"].createRef();
          this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
        }
        componentDidMount() {
          this.componentDidUpdate(this.props);
        }
        componentDidUpdate(prevProps) {
          const node = this.ref.current;
          attachProps(node, this.props, prevProps);
        }
        render() {
          const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = tslib.__rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
          const propsToPass = Object.keys(cProps).reduce((acc, name) => {
            if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
              const eventName = name.substring(2).toLowerCase();
              if (isCoveredByReact(eventName)) {
                acc[name] = cProps[name];
              }
            } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
              acc[camelToDashCase(name)] = cProps[name];
            }
            return acc;
          }, {});
          const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
          if (routerLinkComponent) {
            if (this.props.routerLink && !this.props.href) {
              newProps.href = this.props.routerLink;
            }
            if (newProps.onClick) {
              const oldClick = newProps.onClick;
              newProps.onClick = (e) => {
                oldClick(e);
                if (!e.defaultPrevented) {
                  this.handleClick(e);
                }
              };
            } else {
              newProps.onClick = this.handleClick;
            }
          }
          return React__default["default"].createElement(tagName, newProps, children);
        }
        static get displayName() {
          return displayName;
        }
        static get contextType() {
          return NavContext;
        }
      };
      return createForwardRef(ReactComponent, displayName);
    };
    var IonApp = createReactComponent("ion-app");
    var IonTab = createReactComponent("ion-tab");
    var IonRouterLink = createReactComponent("ion-router-link", true);
    var IonAvatar = createReactComponent("ion-avatar");
    var IonBackdrop = createReactComponent("ion-backdrop");
    var IonBadge = createReactComponent("ion-badge");
    var IonButton = createReactComponent("ion-button", true);
    var IonButtons = createReactComponent("ion-buttons");
    var IonCard = createReactComponent("ion-card", true);
    var IonCardContent = createReactComponent("ion-card-content");
    var IonCardHeader = createReactComponent("ion-card-header");
    var IonCardSubtitle = createReactComponent("ion-card-subtitle");
    var IonCardTitle = createReactComponent("ion-card-title");
    var IonCheckbox = createReactComponent("ion-checkbox");
    var IonCol = createReactComponent("ion-col");
    var IonContent = createReactComponent("ion-content");
    var IonChip = createReactComponent("ion-chip");
    var IonDatetime = createReactComponent("ion-datetime");
    var IonFab = createReactComponent("ion-fab");
    var IonFabButton = createReactComponent("ion-fab-button", true);
    var IonFabList = createReactComponent("ion-fab-list");
    var IonFooter = createReactComponent("ion-footer");
    var IonGrid = createReactComponent("ion-grid");
    var IonHeader = createReactComponent("ion-header");
    var IonImg = createReactComponent("ion-img");
    var IonInfiniteScroll = createReactComponent("ion-infinite-scroll");
    var IonInfiniteScrollContent = createReactComponent("ion-infinite-scroll-content");
    var IonInput = createReactComponent("ion-input");
    var IonItem = createReactComponent("ion-item", true);
    var IonItemDivider = createReactComponent("ion-item-divider");
    var IonItemGroup = createReactComponent("ion-item-group");
    var IonItemOption = createReactComponent("ion-item-option", true);
    var IonItemOptions = createReactComponent("ion-item-options");
    var IonItemSliding = createReactComponent("ion-item-sliding");
    var IonLabel = createReactComponent("ion-label");
    var IonList = createReactComponent("ion-list");
    var IonListHeader = createReactComponent("ion-list-header");
    var IonMenu = createReactComponent("ion-menu");
    var IonMenuButton = createReactComponent("ion-menu-button");
    var IonMenuToggle = createReactComponent("ion-menu-toggle");
    var IonNote = createReactComponent("ion-note");
    var IonPickerColumn = createReactComponent("ion-picker-column");
    var IonNav = createReactComponent("ion-nav");
    var IonProgressBar = createReactComponent("ion-progress-bar");
    var IonRadio = createReactComponent("ion-radio");
    var IonRadioGroup = createReactComponent("ion-radio-group");
    var IonRange = createReactComponent("ion-range");
    var IonRefresher = createReactComponent("ion-refresher");
    var IonRefresherContent = createReactComponent("ion-refresher-content");
    var IonReorder = createReactComponent("ion-reorder");
    var IonReorderGroup = createReactComponent("ion-reorder-group");
    var IonRippleEffect = createReactComponent("ion-ripple-effect");
    var IonRow = createReactComponent("ion-row");
    var IonSearchbar = createReactComponent("ion-searchbar");
    var IonSegment = createReactComponent("ion-segment");
    var IonSegmentButton = createReactComponent("ion-segment-button");
    var IonSelect = createReactComponent("ion-select");
    var IonSelectOption = createReactComponent("ion-select-option");
    var IonSelectPopover = createReactComponent("ion-select-popover");
    var IonSkeletonText = createReactComponent("ion-skeleton-text");
    var IonSlide = createReactComponent("ion-slide");
    var IonSlides = createReactComponent("ion-slides");
    var IonSpinner = createReactComponent("ion-spinner");
    var IonSplitPane = createReactComponent("ion-split-pane");
    var IonText = createReactComponent("ion-text");
    var IonTextarea = createReactComponent("ion-textarea");
    var IonThumbnail = createReactComponent("ion-thumbnail");
    var IonTitle = createReactComponent("ion-title");
    var IonToggle = createReactComponent("ion-toggle");
    var IonToolbar = createReactComponent("ion-toolbar");
    var IonVirtualScroll = createReactComponent("ion-virtual-scroll");
    var createControllerComponent = (displayName, controller) => {
      const didDismissEventName = `on${displayName}DidDismiss`;
      const didPresentEventName = `on${displayName}DidPresent`;
      const willDismissEventName = `on${displayName}WillDismiss`;
      const willPresentEventName = `on${displayName}WillPresent`;
      class Overlay extends React__default["default"].Component {
        constructor(props) {
          super(props);
          this.isUnmounted = false;
          this.handleDismiss = this.handleDismiss.bind(this);
        }
        static get displayName() {
          return displayName;
        }
        async componentDidMount() {
          const { isOpen } = this.props;
          if (isOpen) {
            this.present();
          }
        }
        componentWillUnmount() {
          this.isUnmounted = true;
          if (this.overlay) {
            this.overlay.dismiss();
          }
        }
        async componentDidUpdate(prevProps) {
          if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
            this.present(prevProps);
          }
          if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
            await this.overlay.dismiss();
          }
        }
        handleDismiss(event) {
          if (this.props.onDidDismiss) {
            this.props.onDidDismiss(event);
          }
          setRef(this.props.forwardedRef, null);
        }
        async present(prevProps) {
          const _a = this.props, cProps = tslib.__rest(_a, ["isOpen", "onDidDismiss", "onDidPresent", "onWillDismiss", "onWillPresent"]);
          this.overlay = await controller.create(Object.assign({}, cProps));
          attachProps(this.overlay, {
            [didDismissEventName]: this.handleDismiss,
            [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e),
            [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e),
            [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e)
          }, prevProps);
          if (this.props.isOpen === true && this.isUnmounted === false) {
            setRef(this.props.forwardedRef, this.overlay);
            await this.overlay.present();
          }
        }
        render() {
          return null;
        }
      }
      return React__default["default"].forwardRef((props, ref) => {
        return React__default["default"].createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));
      });
    };
    var IonAlert = createControllerComponent("IonAlert", core.alertController);
    var IonLoading = createControllerComponent("IonLoading", core.loadingController);
    var toastController = {
      create: (options) => core.toastController.create(options),
      dismiss: (data, role, id) => core.toastController.dismiss(data, role, id),
      getTop: () => core.toastController.getTop()
    };
    var IonToast = createControllerComponent("IonToast", toastController);
    var IonPicker = createControllerComponent("IonPicker", core.pickerController);
    var createOverlayComponent = (displayName, controller) => {
      const didDismissEventName = `on${displayName}DidDismiss`;
      const didPresentEventName = `on${displayName}DidPresent`;
      const willDismissEventName = `on${displayName}WillDismiss`;
      const willPresentEventName = `on${displayName}WillPresent`;
      let isDismissing = false;
      class Overlay extends React__default["default"].Component {
        constructor(props) {
          super(props);
          if (typeof document !== "undefined") {
            this.el = document.createElement("div");
          }
          this.handleDismiss = this.handleDismiss.bind(this);
        }
        static get displayName() {
          return displayName;
        }
        componentDidMount() {
          if (this.props.isOpen) {
            this.present();
          }
        }
        componentWillUnmount() {
          if (this.overlay) {
            this.overlay.dismiss();
          }
        }
        handleDismiss(event) {
          if (this.props.onDidDismiss) {
            this.props.onDidDismiss(event);
          }
          setRef(this.props.forwardedRef, null);
        }
        shouldComponentUpdate(nextProps) {
          if (this.overlay && nextProps.isOpen !== this.props.isOpen && nextProps.isOpen === false) {
            isDismissing = true;
          }
          return true;
        }
        async componentDidUpdate(prevProps) {
          if (this.overlay) {
            attachProps(this.overlay, this.props, prevProps);
          }
          if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
            this.present(prevProps);
          }
          if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
            await this.overlay.dismiss();
            isDismissing = false;
            this.forceUpdate();
          }
        }
        async present(prevProps) {
          const _a = this.props, cProps = tslib.__rest(_a, ["children", "isOpen", "onDidDismiss", "onDidPresent", "onWillDismiss", "onWillPresent"]);
          const elementProps = Object.assign(Object.assign({}, cProps), { ref: this.props.forwardedRef, [didDismissEventName]: this.handleDismiss, [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e), [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e), [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e) });
          this.overlay = await controller.create(Object.assign(Object.assign({}, elementProps), { component: this.el, componentProps: {} }));
          setRef(this.props.forwardedRef, this.overlay);
          attachProps(this.overlay, elementProps, prevProps);
          await this.overlay.present();
        }
        render() {
          return ReactDOM__default["default"].createPortal(this.props.isOpen || isDismissing ? this.props.children : null, this.el);
        }
      }
      return React__default["default"].forwardRef((props, ref) => {
        return React__default["default"].createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));
      });
    };
    var actionSheetController = {
      create: (options) => core.actionSheetController.create(options),
      dismiss: (data, role, id) => core.actionSheetController.dismiss(data, role, id),
      getTop: () => core.actionSheetController.getTop()
    };
    var IonActionSheet = createOverlayComponent("IonActionSheet", actionSheetController);
    var IonModal = createOverlayComponent("IonModal", core.modalController);
    var IonPopover = createOverlayComponent("IonPopover", core.popoverController);
    var StackContext2 = React__default["default"].createContext({
      registerIonPage: () => void 0,
      isInOutlet: () => false
    });
    var PageManager = class extends React__default["default"].PureComponent {
      constructor(props) {
        super(props);
        this.ionPageElementRef = React__default["default"].createRef();
        this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);
      }
      componentDidMount() {
        if (this.ionPageElementRef.current) {
          if (this.context.isInOutlet()) {
            this.ionPageElementRef.current.classList.add("ion-page-invisible");
          }
          this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);
          this.ionPageElementRef.current.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
          this.ionPageElementRef.current.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
          this.ionPageElementRef.current.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
          this.ionPageElementRef.current.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
        }
      }
      componentWillUnmount() {
        if (this.ionPageElementRef.current) {
          this.ionPageElementRef.current.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
          this.ionPageElementRef.current.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
          this.ionPageElementRef.current.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
          this.ionPageElementRef.current.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
        }
      }
      ionViewWillEnterHandler() {
        this.ionLifeCycleContext.ionViewWillEnter();
      }
      ionViewDidEnterHandler() {
        this.ionLifeCycleContext.ionViewDidEnter();
      }
      ionViewWillLeaveHandler() {
        this.ionLifeCycleContext.ionViewWillLeave();
      }
      ionViewDidLeaveHandler() {
        this.ionLifeCycleContext.ionViewDidLeave();
      }
      render() {
        const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = tslib.__rest(_a, ["className", "children", "routeInfo", "forwardedRef"]);
        return React__default["default"].createElement(IonLifeCycleContext.Consumer, null, (context) => {
          this.ionLifeCycleContext = context;
          return React__default["default"].createElement("div", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props), children);
        });
      }
      static get contextType() {
        return StackContext2;
      }
    };
    var IonPageInternal = class extends React__default["default"].Component {
      constructor(props) {
        super(props);
      }
      render() {
        const _a = this.props, { className, children, forwardedRef } = _a, props = tslib.__rest(_a, ["className", "children", "forwardedRef"]);
        return this.context.hasIonicRouter() ? React__default["default"].createElement(PageManager, Object.assign({ className: className ? `${className}` : "", routeInfo: this.context.routeInfo, forwardedRef }, props), children) : React__default["default"].createElement("div", Object.assign({ className: className ? `ion-page ${className}` : "ion-page", ref: forwardedRef }, props), children);
      }
      static get displayName() {
        return "IonPage";
      }
      static get contextType() {
        return NavContext;
      }
    };
    var IonPage = createForwardRef(IonPageInternal, "IonPage");
    var IonTabsContext = React__default["default"].createContext({
      activeTab: void 0,
      selectTab: () => false
    });
    var IonTabButtonInner = createReactComponent("ion-tab-button");
    var IonTabBarInner = createReactComponent("ion-tab-bar");
    var IonBackButtonInner = createReactComponent("ion-back-button");
    var IonRouterOutletInner = createReactComponent("ion-router-outlet");
    var IonIconInner = createReactComponent("ion-icon");
    var OutletPageManager = class extends React__default["default"].Component {
      constructor(props) {
        super(props);
      }
      componentDidMount() {
        if (this.ionRouterOutlet) {
          setTimeout(() => {
            this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);
          }, 25);
          this.ionRouterOutlet.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
          this.ionRouterOutlet.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
          this.ionRouterOutlet.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
          this.ionRouterOutlet.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
        }
      }
      componentWillUnmount() {
        if (this.ionRouterOutlet) {
          this.ionRouterOutlet.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
          this.ionRouterOutlet.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
          this.ionRouterOutlet.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
          this.ionRouterOutlet.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
        }
      }
      ionViewWillEnterHandler() {
        this.ionLifeCycleContext.ionViewWillEnter();
      }
      ionViewDidEnterHandler() {
        this.ionLifeCycleContext.ionViewDidEnter();
      }
      ionViewWillLeaveHandler() {
        this.ionLifeCycleContext.ionViewWillLeave();
      }
      ionViewDidLeaveHandler() {
        this.ionLifeCycleContext.ionViewDidLeave();
      }
      render() {
        const _a = this.props, { StackManager: StackManager2, children, routeInfo } = _a, props = tslib.__rest(_a, ["StackManager", "children", "routeInfo"]);
        return React__default["default"].createElement(IonLifeCycleContext.Consumer, null, (context) => {
          this.ionLifeCycleContext = context;
          return React__default["default"].createElement(StackManager2, { routeInfo }, React__default["default"].createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => this.ionRouterOutlet = val }, props), children));
        });
      }
      static get contextType() {
        return StackContext2;
      }
    };
    var IonRouterOutletContainer = class extends React__default["default"].Component {
      constructor(props) {
        super(props);
      }
      render() {
        const StackManager2 = this.context.getStackManager();
        const _a = this.props, { children, forwardedRef } = _a, props = tslib.__rest(_a, ["children", "forwardedRef"]);
        return this.context.hasIonicRouter() ? props.ionPage ? React__default["default"].createElement(OutletPageManager, Object.assign({ StackManager: StackManager2, routeInfo: this.context.routeInfo }, props), children) : React__default["default"].createElement(StackManager2, { routeInfo: this.context.routeInfo }, React__default["default"].createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef }), children)) : React__default["default"].createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children);
      }
      static get contextType() {
        return NavContext;
      }
    };
    var IonRouterOutlet = createForwardRef(IonRouterOutletContainer, "IonRouterOutlet");
    var IonTabButton = class extends React__default["default"].Component {
      constructor(props) {
        super(props);
        this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);
      }
      handleIonTabButtonClick() {
        if (this.props.onClick) {
          this.props.onClick(new CustomEvent("ionTabButtonClick", {
            detail: {
              tab: this.props.tab,
              href: this.props.href,
              routeOptions: this.props.routerOptions
            }
          }));
        }
      }
      render() {
        const _a = this.props, rest = tslib.__rest(_a, ["onClick"]);
        return React__default["default"].createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest));
      }
      static get displayName() {
        return "IonTabButton";
      }
    };
    var IonTabBarUnwrapped = class extends React__default["default"].PureComponent {
      constructor(props) {
        super(props);
        this.setActiveTabOnContext = (_tab) => {
        };
        const tabs = {};
        React__default["default"].Children.forEach(props.children, (child) => {
          var _a, _b, _c, _d;
          if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
            tabs[child.props.tab] = {
              originalHref: child.props.href,
              currentHref: child.props.href,
              originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : void 0,
              currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname) ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : void 0
            };
          }
        });
        this.state = {
          tabs
        };
        this.onTabButtonClick = this.onTabButtonClick.bind(this);
        this.renderTabButton = this.renderTabButton.bind(this);
        this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);
        this.selectTab = this.selectTab.bind(this);
      }
      componentDidMount() {
        const tabs = this.state.tabs;
        const tabKeys = Object.keys(tabs);
        const activeTab = tabKeys.find((key) => {
          const href = tabs[key].originalHref;
          return this.props.routeInfo.pathname.startsWith(href);
        });
        if (activeTab) {
          this.setState({
            activeTab
          });
        }
      }
      componentDidUpdate() {
        if (this.state.activeTab) {
          this.setActiveTabOnContext(this.state.activeTab);
        }
      }
      selectTab(tab) {
        const tabUrl = this.state.tabs[tab];
        if (tabUrl) {
          this.onTabButtonClick(new CustomEvent("ionTabButtonClick", {
            detail: {
              href: tabUrl.currentHref,
              tab,
              selected: tab === this.state.activeTab,
              routeOptions: void 0
            }
          }));
          return true;
        }
        return false;
      }
      static getDerivedStateFromProps(props, state) {
        var _a, _b, _c;
        const tabs = Object.assign({}, state.tabs);
        const tabKeys = Object.keys(state.tabs);
        const activeTab = tabKeys.find((key) => {
          const href = state.tabs[key].originalHref;
          return props.routeInfo.pathname.startsWith(href);
        });
        React__default["default"].Children.forEach(props.children, (child) => {
          if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
            const tab = tabs[child.props.tab];
            if (!tab || tab.originalHref !== child.props.href) {
              tabs[child.props.tab] = {
                originalHref: child.props.href,
                currentHref: child.props.href,
                originalRouteOptions: child.props.routeOptions,
                currentRouteOptions: child.props.routeOptions
              };
            }
          }
        });
        const { activeTab: prevActiveTab } = state;
        if (activeTab && prevActiveTab) {
          const prevHref = state.tabs[prevActiveTab].currentHref;
          const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;
          if (activeTab !== prevActiveTab || prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) || prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {
            tabs[activeTab] = {
              originalHref: tabs[activeTab].originalHref,
              currentHref: props.routeInfo.pathname + (props.routeInfo.search || ""),
              originalRouteOptions: tabs[activeTab].originalRouteOptions,
              currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions
            };
            if (props.routeInfo.routeAction === "pop" && activeTab !== prevActiveTab) {
              tabs[prevActiveTab] = {
                originalHref: tabs[prevActiveTab].originalHref,
                currentHref: tabs[prevActiveTab].originalHref,
                originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,
                currentRouteOptions: tabs[prevActiveTab].currentRouteOptions
              };
            }
          }
        }
        activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);
        return {
          activeTab,
          tabs
        };
      }
      onTabButtonClick(e) {
        const tappedTab = this.state.tabs[e.detail.tab];
        const originalHref = tappedTab.originalHref;
        const currentHref = e.detail.href;
        const { activeTab: prevActiveTab } = this.state;
        if (prevActiveTab === e.detail.tab) {
          if (originalHref !== currentHref) {
            this.context.resetTab(e.detail.tab, originalHref, tappedTab.originalRouteOptions);
          }
        } else {
          if (this.props.onIonTabsWillChange) {
            this.props.onIonTabsWillChange(new CustomEvent("ionTabWillChange", { detail: { tab: e.detail.tab } }));
          }
          if (this.props.onIonTabsDidChange) {
            this.props.onIonTabsDidChange(new CustomEvent("ionTabDidChange", { detail: { tab: e.detail.tab } }));
          }
          this.setActiveTabOnContext(e.detail.tab);
          this.context.changeTab(e.detail.tab, currentHref, e.detail.routeOptions);
        }
      }
      renderTabButton(activeTab) {
        return (child) => {
          var _a, _b;
          if (child != null && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
            const href = child.props.tab === activeTab ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;
            const routeOptions = child.props.tab === activeTab ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;
            return React__default["default"].cloneElement(child, {
              href,
              routeOptions,
              onClick: this.onTabButtonClick
            });
          }
          return null;
        };
      }
      render() {
        const { activeTab } = this.state;
        return React__default["default"].createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), React__default["default"].Children.map(this.props.children, this.renderTabButton(activeTab)));
      }
      static get contextType() {
        return NavContext;
      }
    };
    var IonTabBarContainer = React__default["default"].memo((_a) => {
      var { forwardedRef } = _a, props = tslib.__rest(_a, ["forwardedRef"]);
      const context = React2.useContext(NavContext);
      return React__default["default"].createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props, { routeInfo: props.routeInfo || context.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context.setCurrentTab }), props.children);
    });
    var IonTabBar = createForwardRef(IonTabBarContainer, "IonTabBar");
    var IonTabsElement = class extends HTMLElement {
      constructor() {
        super();
      }
    };
    if (window && window.customElements) {
      const element = customElements.get("ion-tabs");
      if (!element) {
        customElements.define("ion-tabs", IonTabsElement);
      }
    }
    var hostStyles = {
      display: "flex",
      position: "absolute",
      top: "0",
      left: "0",
      right: "0",
      bottom: "0",
      flexDirection: "column",
      width: "100%",
      height: "100%",
      contain: "layout size style"
    };
    var tabsInner = {
      position: "relative",
      flex: 1,
      contain: "layout size style"
    };
    var IonTabs = class extends React__default["default"].Component {
      constructor(props) {
        super(props);
        this.routerOutletRef = React__default["default"].createRef();
        this.tabBarRef = React__default["default"].createRef();
        this.ionTabContextState = {
          activeTab: void 0,
          selectTab: () => false
        };
      }
      componentDidMount() {
        if (this.tabBarRef.current) {
          this.ionTabContextState.activeTab = this.tabBarRef.current.state.activeTab;
          this.tabBarRef.current.setActiveTabOnContext = (tab) => {
            this.ionTabContextState.activeTab = tab;
          };
          this.ionTabContextState.selectTab = this.tabBarRef.current.selectTab;
        }
      }
      render() {
        let outlet;
        let tabBar;
        const _a = this.props, { className, onIonTabsDidChange, onIonTabsWillChange } = _a, props = tslib.__rest(_a, ["className", "onIonTabsDidChange", "onIonTabsWillChange"]);
        const children = typeof this.props.children === "function" ? this.props.children(this.ionTabContextState) : this.props.children;
        React__default["default"].Children.forEach(children, (child) => {
          if (child == null || typeof child !== "object" || !child.hasOwnProperty("type")) {
            return;
          }
          if (child.type === IonRouterOutlet || child.type.isRouterOutlet) {
            outlet = React__default["default"].cloneElement(child, { tabs: true });
          } else if (child.type === React2.Fragment && child.props.children[0].type === IonRouterOutlet) {
            outlet = child.props.children[0];
          }
          let childProps = {
            ref: this.tabBarRef
          };
          if (onIonTabsDidChange !== void 0) {
            childProps = Object.assign(Object.assign({}, childProps), { onIonTabsDidChange });
          }
          if (onIonTabsWillChange !== void 0) {
            childProps = Object.assign(Object.assign({}, childProps), { onIonTabsWillChange });
          }
          if (child.type === IonTabBar || child.type.isTabBar) {
            tabBar = React__default["default"].cloneElement(child, childProps);
          } else if (child.type === React2.Fragment && (child.props.children[1].type === IonTabBar || child.props.children[1].type.isTabBar)) {
            tabBar = React__default["default"].cloneElement(child.props.children[1], childProps);
          }
        });
        if (!outlet) {
          throw new Error("IonTabs must contain an IonRouterOutlet");
        }
        if (!tabBar) {
          throw new Error("IonTabs needs a IonTabBar");
        }
        return React__default["default"].createElement(IonTabsContext.Provider, { value: this.ionTabContextState }, this.context.hasIonicRouter() ? React__default["default"].createElement(PageManager, Object.assign({ className: className ? `${className}` : "", routeInfo: this.context.routeInfo }, props), React__default["default"].createElement("ion-tabs", { className: "ion-tabs", style: hostStyles }, tabBar.props.slot === "top" ? tabBar : null, React__default["default"].createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet), tabBar.props.slot === "bottom" ? tabBar : null)) : React__default["default"].createElement("div", Object.assign({ className: className ? `${className}` : "ion-tabs" }, props, { style: hostStyles }), tabBar.props.slot === "top" ? tabBar : null, React__default["default"].createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet), tabBar.props.slot === "bottom" ? tabBar : null));
      }
      static get contextType() {
        return NavContext;
      }
    };
    var IonBackButton = (() => class extends React__default["default"].Component {
      constructor() {
        super(...arguments);
        this.clickButton = (e) => {
          const { defaultHref, routerAnimation } = this.props;
          if (this.context.hasIonicRouter()) {
            e.stopPropagation();
            this.context.goBack(defaultHref, routerAnimation);
          } else if (defaultHref !== void 0) {
            window.location.href = defaultHref;
          }
        };
      }
      render() {
        return React__default["default"].createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props));
      }
      static get displayName() {
        return "IonBackButton";
      }
      static get contextType() {
        return NavContext;
      }
    })();
    var isDevMode = () => {
      return process && define_process_env_default && true;
    };
    var warnings = {};
    var deprecationWarning = (key, message) => {
      if (isDevMode()) {
        if (!warnings[key]) {
          console.warn(message);
          warnings[key] = true;
        }
      }
    };
    var IonIconContainer = class extends React__default["default"].PureComponent {
      constructor(props) {
        super(props);
        if (this.props.name) {
          deprecationWarning("icon-name", 'In Ionic React, you import icons from "ionicons/icons" and set the icon you imported to the "icon" property. Setting the "name" property has no effect.');
        }
      }
      render() {
        var _a, _b;
        const _c = this.props, { icon, ios, md } = _c, rest = tslib.__rest(_c, ["icon", "ios", "md"]);
        let iconToUse;
        if (ios || md) {
          if (isPlatform("ios")) {
            iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;
          } else {
            iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;
          }
        } else {
          iconToUse = icon;
        }
        return React__default["default"].createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children);
      }
      static get contextType() {
        return NavContext;
      }
    };
    var IonIcon = createForwardRef(IonIconContainer, "IonIcon");
    var IonRoute2 = class extends React__default["default"].PureComponent {
      render() {
        const IonRouteInner2 = this.context.getIonRoute();
        if (!this.context.hasIonicRouter() || !IonRoute2) {
          console.error("You either do not have an Ionic Router package, or your router does not support using <IonRoute>");
          return null;
        }
        return React__default["default"].createElement(IonRouteInner2, Object.assign({}, this.props));
      }
      static get contextType() {
        return NavContext;
      }
    };
    var IonRedirect = class extends React__default["default"].PureComponent {
      render() {
        const IonRedirectInner = this.context.getIonRedirect();
        if (!this.context.hasIonicRouter() || !IonRedirect) {
          console.error("You either do not have an Ionic Router package, or your router does not support using <IonRedirect>");
          return null;
        }
        return React__default["default"].createElement(IonRedirectInner, Object.assign({}, this.props));
      }
      static get contextType() {
        return NavContext;
      }
    };
    var IonRouterContext = React__default["default"].createContext({
      routeInfo: void 0,
      push: () => {
        throw new Error("An Ionic Router is required for IonRouterContext");
      },
      back: () => {
        throw new Error("An Ionic Router is required for IonRouterContext");
      },
      canGoBack: () => {
        throw new Error("An Ionic Router is required for IonRouterContext");
      },
      nativeBack: () => {
        throw new Error("An Ionic Router is required for IonRouterContext");
      }
    });
    function useIonRouter() {
      const context = React2.useContext(IonRouterContext);
      return {
        back: context.back,
        push: context.push,
        goBack: context.back,
        canGoBack: context.canGoBack,
        routeInfo: context.routeInfo
      };
    }
    var CreateAnimation = class extends React__default["default"].PureComponent {
      constructor(props) {
        super(props);
        this.nodes = new Map();
        this.animation = core.createAnimation(props.id);
      }
      setupAnimation(props) {
        const animation = this.animation;
        if (this.nodes.size > 0) {
          animation.addElement(Array.from(this.nodes.values()));
        }
        checkConfig(animation, props);
        checkPlayback(animation, props);
      }
      componentDidMount() {
        const props = this.props;
        this.setupAnimation(props);
      }
      componentDidUpdate(prevProps) {
        const animation = this.animation;
        const props = this.props;
        checkConfig(animation, props, prevProps);
        checkProgress(animation, props, prevProps);
        checkPlayback(animation, props, prevProps);
      }
      render() {
        const { children } = this.props;
        return React__default["default"].createElement(React__default["default"].Fragment, null, React__default["default"].Children.map(children, (child, id) => React__default["default"].cloneElement(child, { ref: (el) => this.nodes.set(id, el) })));
      }
    };
    var checkConfig = (animation, currentProps = {}, prevProps = {}) => {
      const reservedProps = [
        "children",
        "progressStart",
        "progressStep",
        "progressEnd",
        "pause",
        "stop",
        "destroy",
        "play",
        "from",
        "to",
        "fromTo",
        "onFinish"
      ];
      for (const key in currentProps) {
        if (currentProps.hasOwnProperty(key) && !reservedProps.includes(key) && currentProps[key] !== prevProps[key]) {
          animation[key](currentProps[key]);
        }
      }
      const fromValues = currentProps.from;
      if (fromValues && fromValues !== prevProps.from) {
        const values = Array.isArray(fromValues) ? fromValues : [fromValues];
        values.forEach((val) => animation.from(val.property, val.value));
      }
      const toValues = currentProps.to;
      if (toValues && toValues !== prevProps.to) {
        const values = Array.isArray(toValues) ? toValues : [toValues];
        values.forEach((val) => animation.to(val.property, val.value));
      }
      const fromToValues = currentProps.fromTo;
      if (fromToValues && fromToValues !== prevProps.fromTo) {
        const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];
        values.forEach((val) => animation.fromTo(val.property, val.fromValue, val.toValue));
      }
      const onFinishValues = currentProps.onFinish;
      if (onFinishValues && onFinishValues !== prevProps.onFinish) {
        const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];
        values.forEach((val) => animation.onFinish(val.callback, val.opts));
      }
    };
    var checkProgress = (animation, currentProps = {}, prevProps = {}) => {
      var _a, _b, _c, _d, _e;
      const { progressStart, progressStep, progressEnd } = currentProps;
      if (progressStart && (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) || ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {
        animation.progressStart(progressStart.forceLinearEasing, progressStart.step);
      }
      if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {
        animation.progressStep(progressStep.step);
      }
      if (progressEnd && (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) || ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {
        animation.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);
      }
    };
    var checkPlayback = (animation, currentProps = {}, prevProps = {}) => {
      if (!prevProps.play && currentProps.play) {
        animation.play();
      }
      if (!prevProps.pause && currentProps.pause) {
        animation.pause();
      }
      if (!prevProps.stop && currentProps.stop) {
        animation.stop();
      }
      if (!prevProps.destroy && currentProps.destroy) {
        animation.destroy();
      }
    };
    function useController(displayName, controller) {
      const overlayRef = React2.useRef();
      const didDismissEventName = React2.useMemo(() => `on${displayName}DidDismiss`, [displayName]);
      const didPresentEventName = React2.useMemo(() => `on${displayName}DidPresent`, [displayName]);
      const willDismissEventName = React2.useMemo(() => `on${displayName}WillDismiss`, [displayName]);
      const willPresentEventName = React2.useMemo(() => `on${displayName}WillPresent`, [displayName]);
      const present = async (options) => {
        if (overlayRef.current) {
          return;
        }
        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = tslib.__rest(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
        const handleDismiss = (event) => {
          if (onDidDismiss) {
            onDidDismiss(event);
          }
          overlayRef.current = void 0;
        };
        overlayRef.current = await controller.create(Object.assign({}, rest));
        attachProps(overlayRef.current, {
          [didDismissEventName]: handleDismiss,
          [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),
          [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),
          [willPresentEventName]: (e) => onWillPresent && onWillPresent(e)
        });
        overlayRef.current.present();
      };
      const dismiss = async () => {
        overlayRef.current && await overlayRef.current.dismiss();
        overlayRef.current = void 0;
      };
      return {
        present,
        dismiss
      };
    }
    function useIonActionSheet() {
      const controller = useController("IonActionSheet", core.actionSheetController);
      function present(buttonsOrOptions, header) {
        if (Array.isArray(buttonsOrOptions)) {
          controller.present({
            buttons: buttonsOrOptions,
            header
          });
        } else {
          controller.present(buttonsOrOptions);
        }
      }
      return [
        present,
        controller.dismiss
      ];
    }
    function useIonAlert() {
      const controller = useController("IonAlert", core.alertController);
      function present(messageOrOptions, buttons) {
        if (typeof messageOrOptions === "string") {
          controller.present({
            message: messageOrOptions,
            buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: "Ok" }]
          });
        } else {
          controller.present(messageOrOptions);
        }
      }
      return [
        present,
        controller.dismiss
      ];
    }
    function useIonToast() {
      const controller = useController("IonToast", core.toastController);
      function present(messageOrOptions, duration) {
        if (typeof messageOrOptions === "string") {
          controller.present({
            message: messageOrOptions,
            duration
          });
        } else {
          controller.present(messageOrOptions);
        }
      }
      return [
        present,
        controller.dismiss
      ];
    }
    function useOverlay(displayName, controller, component, componentProps) {
      const overlayRef = React2.useRef();
      const containerElRef = React2.useRef();
      const didDismissEventName = React2.useMemo(() => `on${displayName}DidDismiss`, [displayName]);
      const didPresentEventName = React2.useMemo(() => `on${displayName}DidPresent`, [displayName]);
      const willDismissEventName = React2.useMemo(() => `on${displayName}WillDismiss`, [displayName]);
      const willPresentEventName = React2.useMemo(() => `on${displayName}WillPresent`, [displayName]);
      const [isOpen, setIsOpen] = React2.useState(false);
      React2.useEffect(() => {
        if (isOpen && component && containerElRef.current) {
          if (React__default["default"].isValidElement(component)) {
            ReactDOM__default["default"].render(component, containerElRef.current);
          } else {
            ReactDOM__default["default"].render(React__default["default"].createElement(component, componentProps), containerElRef.current);
          }
        }
      }, [component, containerElRef.current, isOpen, componentProps]);
      const present = async (options) => {
        if (overlayRef.current) {
          return;
        }
        const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = tslib.__rest(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
        if (typeof document !== "undefined") {
          containerElRef.current = document.createElement("div");
        }
        overlayRef.current = await controller.create(Object.assign(Object.assign({}, rest), { component: containerElRef.current }));
        attachProps(overlayRef.current, {
          [didDismissEventName]: handleDismiss,
          [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),
          [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),
          [willPresentEventName]: (e) => onWillPresent && onWillPresent(e)
        });
        overlayRef.current.present();
        setIsOpen(true);
        function handleDismiss(event) {
          if (onDidDismiss) {
            onDidDismiss(event);
          }
          overlayRef.current = void 0;
          containerElRef.current = void 0;
          setIsOpen(false);
        }
      };
      const dismiss = async () => {
        overlayRef.current && await overlayRef.current.dismiss();
        overlayRef.current = void 0;
        containerElRef.current = void 0;
      };
      return {
        present,
        dismiss
      };
    }
    function useIonModal(component, componentProps) {
      const controller = useOverlay("IonModal", core.modalController, component, componentProps);
      function present(options = {}) {
        controller.present(options);
      }
      return [
        present,
        controller.dismiss
      ];
    }
    function useIonPopover(component, componentProps) {
      const controller = useOverlay("IonPopover", core.popoverController, component, componentProps);
      function present(options = {}) {
        controller.present(options);
      }
      return [
        present,
        controller.dismiss
      ];
    }
    function useIonPicker() {
      const controller = useController("IonPicker", core.pickerController);
      function present(columnsOrOptions, buttons) {
        if (Array.isArray(columnsOrOptions)) {
          controller.present({
            columns: columnsOrOptions,
            buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: "Ok" }]
          });
        } else {
          controller.present(columnsOrOptions);
        }
      }
      return [present, controller.dismiss];
    }
    function useIonLoading() {
      const controller = useController("IonLoading", core.loadingController);
      function present(messageOrOptions = "", duration, spinner) {
        if (typeof messageOrOptions === "string") {
          controller.present({
            message: messageOrOptions,
            duration,
            spinner: spinner !== null && spinner !== void 0 ? spinner : "lines"
          });
        } else {
          controller.present(messageOrOptions);
        }
      }
      return [present, controller.dismiss];
    }
    ionicons.addIcons({
      "arrow-back-sharp": icons.arrowBackSharp,
      "caret-back-sharp": icons.caretBackSharp,
      "chevron-back": icons.chevronBack,
      "chevron-forward": icons.chevronForward,
      close: icons.close,
      "close-circle": icons.closeCircle,
      "close-sharp": icons.closeSharp,
      "menu-outline": icons.menuOutline,
      "menu-sharp": icons.menuSharp,
      "reorder-two-sharp": icons.reorderTwoSharp,
      "reorder-three-outline": icons.reorderThreeOutline,
      "search-outline": icons.searchOutline,
      "search-sharp": icons.searchSharp
    });
    if (typeof window !== "undefined") {
      loader.defineCustomElements(window);
    }
    var RouteManagerContext2 = React__default["default"].createContext({
      addViewItem: () => void 0,
      canGoBack: () => void 0,
      clearOutlet: () => void 0,
      createViewItem: () => void 0,
      findViewItemByPathname: () => void 0,
      findLeavingViewItemByRouteInfo: () => void 0,
      findViewItemByRouteInfo: () => void 0,
      getChildrenToRender: () => void 0,
      goBack: () => void 0,
      unMountViewItem: () => void 0
    });
    var ViewLifeCycleManager2 = class extends React__default["default"].Component {
      constructor(props) {
        super(props);
        this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
        this._isMounted = false;
        this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
          if (!this.props.mount) {
            if (this._isMounted) {
              this.setState({
                show: false
              }, () => this.props.removeView());
            }
          }
        });
        this.state = {
          show: true
        };
      }
      componentDidMount() {
        this._isMounted = true;
      }
      componentWillUnmount() {
        this._isMounted = false;
      }
      render() {
        const { show } = this.state;
        return React__default["default"].createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children);
      }
    };
    var LocationHistory2 = class {
      constructor() {
        this.locationHistory = [];
        this.tabHistory = {};
      }
      add(routeInfo) {
        if (routeInfo.routeAction === "push" || routeInfo.routeAction == null) {
          this._add(routeInfo);
        } else if (routeInfo.routeAction === "pop") {
          this._pop(routeInfo);
        } else if (routeInfo.routeAction === "replace") {
          this._replace(routeInfo);
        }
        if (routeInfo.routeDirection === "root") {
          this._clear();
          this._add(routeInfo);
        }
      }
      clearTabStack(tab) {
        const routeInfos = this._getRouteInfosByKey(tab);
        if (routeInfos) {
          routeInfos.forEach((ri) => {
            this.locationHistory = this.locationHistory.filter((x) => x.id !== ri.id);
          });
          this.tabHistory[tab] = [];
        }
      }
      update(routeInfo) {
        const locationIndex = this.locationHistory.findIndex((x) => x.id === routeInfo.id);
        if (locationIndex > -1) {
          this.locationHistory.splice(locationIndex, 1, routeInfo);
        }
        const tabArray = this.tabHistory[routeInfo.tab || ""];
        if (tabArray) {
          const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);
          if (tabIndex > -1) {
            tabArray.splice(tabIndex, 1, routeInfo);
          } else {
            tabArray.push(routeInfo);
          }
        } else if (routeInfo.tab) {
          this.tabHistory[routeInfo.tab] = [routeInfo];
        }
      }
      _add(routeInfo) {
        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
        if (routeInfos) {
          if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {
            routeInfos.pop();
          }
          routeInfos.push(routeInfo);
        }
        this.locationHistory.push(routeInfo);
      }
      _areRoutesEqual(route1, route2) {
        if (!route1 || !route2) {
          return false;
        }
        return route1.pathname === route2.pathname && route1.search === route2.search;
      }
      _pop(routeInfo) {
        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
        if (routeInfos) {
          routeInfos.pop();
          routeInfos.pop();
          routeInfos.push(routeInfo);
        }
        this.locationHistory.pop();
        this.locationHistory.pop();
        this.locationHistory.push(routeInfo);
      }
      _replace(routeInfo) {
        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
        routeInfos && routeInfos.pop();
        this.locationHistory.pop();
        this._add(routeInfo);
      }
      _clear() {
        const keys = Object.keys(this.tabHistory);
        keys.forEach((k) => this.tabHistory[k] = []);
        this.locationHistory = [];
      }
      _getRouteInfosByKey(key) {
        let routeInfos;
        if (key) {
          routeInfos = this.tabHistory[key];
          if (!routeInfos) {
            routeInfos = this.tabHistory[key] = [];
          }
        }
        return routeInfos;
      }
      getFirstRouteInfoForTab(tab) {
        const routeInfos = this._getRouteInfosByKey(tab);
        if (routeInfos) {
          return routeInfos[0];
        }
        return void 0;
      }
      getCurrentRouteInfoForTab(tab) {
        const routeInfos = this._getRouteInfosByKey(tab);
        if (routeInfos) {
          return routeInfos[routeInfos.length - 1];
        }
        return void 0;
      }
      findLastLocation(routeInfo) {
        const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
        if (routeInfos) {
          for (let i = routeInfos.length - 2; i >= 0; i--) {
            const ri = routeInfos[i];
            if (ri) {
              if (ri.pathname === routeInfo.pushedByRoute) {
                return ri;
              }
            }
          }
        }
        for (let i = this.locationHistory.length - 2; i >= 0; i--) {
          const ri = this.locationHistory[i];
          if (ri) {
            if (ri.pathname === routeInfo.pushedByRoute) {
              return ri;
            }
          }
        }
        return void 0;
      }
      previous() {
        return this.locationHistory[this.locationHistory.length - 2] || this.locationHistory[this.locationHistory.length - 1];
      }
      current() {
        return this.locationHistory[this.locationHistory.length - 1];
      }
      canGoBack() {
        return this.locationHistory.length > 1;
      }
    };
    var NavManager2 = class extends React__default["default"].PureComponent {
      constructor(props) {
        super(props);
        this._isMounted = false;
        this.ionRouterContextValue = {
          push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {
            this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);
          },
          back: (animationBuilder) => {
            this.goBack(void 0, animationBuilder);
          },
          canGoBack: () => this.props.locationHistory.canGoBack(),
          nativeBack: () => this.props.onNativeBack(),
          routeInfo: this.props.routeInfo
        };
        this.state = {
          goBack: this.goBack.bind(this),
          hasIonicRouter: () => true,
          navigate: this.navigate.bind(this),
          getIonRedirect: this.getIonRedirect.bind(this),
          getIonRoute: this.getIonRoute.bind(this),
          getStackManager: this.getStackManager.bind(this),
          getPageManager: this.getPageManager.bind(this),
          routeInfo: this.props.routeInfo,
          setCurrentTab: this.props.onSetCurrentTab,
          changeTab: this.props.onChangeTab,
          resetTab: this.props.onResetTab
        };
        if (typeof document !== "undefined") {
          this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);
          document.addEventListener("ionBackButton", this.handleHardwareBackButton);
        }
      }
      componentDidMount() {
        this._isMounted = true;
      }
      componentWillUnmount() {
        if (typeof document !== "undefined") {
          document.removeEventListener("ionBackButton", this.handleHardwareBackButton);
          this._isMounted = false;
        }
      }
      handleHardwareBackButton(e) {
        e.detail.register(0, (processNextHandler) => {
          if (this._isMounted) {
            this.nativeGoBack();
            processNextHandler();
          }
        });
      }
      goBack(route, animationBuilder) {
        this.props.onNavigateBack(route, animationBuilder);
      }
      nativeGoBack() {
        this.props.onNativeBack();
      }
      navigate(path, direction = "forward", action = "push", animationBuilder, options, tab) {
        this.props.onNavigate(path, action, direction, animationBuilder, options, tab);
      }
      getPageManager() {
        return PageManager;
      }
      getIonRedirect() {
        return this.props.ionRedirect;
      }
      getIonRoute() {
        return this.props.ionRoute;
      }
      getStackManager() {
        return this.props.stackManager;
      }
      render() {
        return React__default["default"].createElement(NavContext.Provider, { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) }, React__default["default"].createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children));
      }
    };
    var ViewStacks2 = class {
      constructor() {
        this.viewStacks = {};
        this.add = this.add.bind(this);
        this.clear = this.clear.bind(this);
        this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);
        this.remove = this.remove.bind(this);
      }
      add(viewItem) {
        const { outletId } = viewItem;
        if (!this.viewStacks[outletId]) {
          this.viewStacks[outletId] = [viewItem];
        } else {
          this.viewStacks[outletId].push(viewItem);
        }
      }
      clear(outletId) {
        setTimeout(() => {
          delete this.viewStacks[outletId];
        }, 500);
      }
      getViewItemsForOutlet(outletId) {
        return this.viewStacks[outletId] || [];
      }
      remove(viewItem) {
        const { outletId } = viewItem;
        const viewStack = this.viewStacks[outletId];
        if (viewStack) {
          const viewItemToRemove = viewStack.find((x) => x.id === viewItem.id);
          if (viewItemToRemove) {
            viewItemToRemove.mount = false;
            this.viewStacks[outletId] = viewStack.filter((x) => x.id !== viewItemToRemove.id);
          }
        }
      }
      getStackIds() {
        return Object.keys(this.viewStacks);
      }
      getAllViewItems() {
        const keys = this.getStackIds();
        const viewItems = [];
        keys.forEach((k) => {
          viewItems.push(...this.viewStacks[k]);
        });
        return viewItems;
      }
    };
    var ids = { main: 0 };
    var generateId2 = (type = "main") => {
      var _a;
      const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
      ids[type] = id;
      return id.toString();
    };
    Object.defineProperty(exports, "IonicSafeString", {
      enumerable: true,
      get: function() {
        return core.IonicSafeString;
      }
    });
    Object.defineProperty(exports, "createAnimation", {
      enumerable: true,
      get: function() {
        return core.createAnimation;
      }
    });
    Object.defineProperty(exports, "createGesture", {
      enumerable: true,
      get: function() {
        return core.createGesture;
      }
    });
    Object.defineProperty(exports, "iosTransitionAnimation", {
      enumerable: true,
      get: function() {
        return core.iosTransitionAnimation;
      }
    });
    Object.defineProperty(exports, "mdTransitionAnimation", {
      enumerable: true,
      get: function() {
        return core.mdTransitionAnimation;
      }
    });
    Object.defineProperty(exports, "setupConfig", {
      enumerable: true,
      get: function() {
        return core.setupConfig;
      }
    });
    exports.CreateAnimation = CreateAnimation;
    exports.DefaultIonLifeCycleContext = DefaultIonLifeCycleContext;
    exports.IonActionSheet = IonActionSheet;
    exports.IonAlert = IonAlert;
    exports.IonApp = IonApp;
    exports.IonAvatar = IonAvatar;
    exports.IonBackButton = IonBackButton;
    exports.IonBackdrop = IonBackdrop;
    exports.IonBadge = IonBadge;
    exports.IonButton = IonButton;
    exports.IonButtons = IonButtons;
    exports.IonCard = IonCard;
    exports.IonCardContent = IonCardContent;
    exports.IonCardHeader = IonCardHeader;
    exports.IonCardSubtitle = IonCardSubtitle;
    exports.IonCardTitle = IonCardTitle;
    exports.IonCheckbox = IonCheckbox;
    exports.IonChip = IonChip;
    exports.IonCol = IonCol;
    exports.IonContent = IonContent;
    exports.IonDatetime = IonDatetime;
    exports.IonFab = IonFab;
    exports.IonFabButton = IonFabButton;
    exports.IonFabList = IonFabList;
    exports.IonFooter = IonFooter;
    exports.IonGrid = IonGrid;
    exports.IonHeader = IonHeader;
    exports.IonIcon = IonIcon;
    exports.IonImg = IonImg;
    exports.IonInfiniteScroll = IonInfiniteScroll;
    exports.IonInfiniteScrollContent = IonInfiniteScrollContent;
    exports.IonInput = IonInput;
    exports.IonItem = IonItem;
    exports.IonItemDivider = IonItemDivider;
    exports.IonItemGroup = IonItemGroup;
    exports.IonItemOption = IonItemOption;
    exports.IonItemOptions = IonItemOptions;
    exports.IonItemSliding = IonItemSliding;
    exports.IonLabel = IonLabel;
    exports.IonLifeCycleContext = IonLifeCycleContext;
    exports.IonList = IonList;
    exports.IonListHeader = IonListHeader;
    exports.IonLoading = IonLoading;
    exports.IonMenu = IonMenu;
    exports.IonMenuButton = IonMenuButton;
    exports.IonMenuToggle = IonMenuToggle;
    exports.IonModal = IonModal;
    exports.IonNav = IonNav;
    exports.IonNote = IonNote;
    exports.IonPage = IonPage;
    exports.IonPicker = IonPicker;
    exports.IonPickerColumn = IonPickerColumn;
    exports.IonPopover = IonPopover;
    exports.IonProgressBar = IonProgressBar;
    exports.IonRadio = IonRadio;
    exports.IonRadioGroup = IonRadioGroup;
    exports.IonRange = IonRange;
    exports.IonRedirect = IonRedirect;
    exports.IonRefresher = IonRefresher;
    exports.IonRefresherContent = IonRefresherContent;
    exports.IonReorder = IonReorder;
    exports.IonReorderGroup = IonReorderGroup;
    exports.IonRippleEffect = IonRippleEffect;
    exports.IonRoute = IonRoute2;
    exports.IonRouterContext = IonRouterContext;
    exports.IonRouterLink = IonRouterLink;
    exports.IonRouterOutlet = IonRouterOutlet;
    exports.IonRow = IonRow;
    exports.IonSearchbar = IonSearchbar;
    exports.IonSegment = IonSegment;
    exports.IonSegmentButton = IonSegmentButton;
    exports.IonSelect = IonSelect;
    exports.IonSelectOption = IonSelectOption;
    exports.IonSelectPopover = IonSelectPopover;
    exports.IonSkeletonText = IonSkeletonText;
    exports.IonSlide = IonSlide;
    exports.IonSlides = IonSlides;
    exports.IonSpinner = IonSpinner;
    exports.IonSplitPane = IonSplitPane;
    exports.IonTab = IonTab;
    exports.IonTabBar = IonTabBar;
    exports.IonTabButton = IonTabButton;
    exports.IonTabs = IonTabs;
    exports.IonTabsContext = IonTabsContext;
    exports.IonText = IonText;
    exports.IonTextarea = IonTextarea;
    exports.IonThumbnail = IonThumbnail;
    exports.IonTitle = IonTitle;
    exports.IonToast = IonToast;
    exports.IonToggle = IonToggle;
    exports.IonToolbar = IonToolbar;
    exports.IonVirtualScroll = IonVirtualScroll;
    exports.LocationHistory = LocationHistory2;
    exports.NavContext = NavContext;
    exports.NavManager = NavManager2;
    exports.RouteManagerContext = RouteManagerContext2;
    exports.StackContext = StackContext2;
    exports.ViewLifeCycleManager = ViewLifeCycleManager2;
    exports.ViewStacks = ViewStacks2;
    exports.generateId = generateId2;
    exports.getConfig = getConfig2;
    exports.getPlatforms = getPlatforms;
    exports.isPlatform = isPlatform;
    exports.useIonActionSheet = useIonActionSheet;
    exports.useIonAlert = useIonAlert;
    exports.useIonLoading = useIonLoading;
    exports.useIonModal = useIonModal;
    exports.useIonPicker = useIonPicker;
    exports.useIonPopover = useIonPopover;
    exports.useIonRouter = useIonRouter;
    exports.useIonToast = useIonToast;
    exports.useIonViewDidEnter = useIonViewDidEnter;
    exports.useIonViewDidLeave = useIonViewDidLeave;
    exports.useIonViewWillEnter = useIonViewWillEnter;
    exports.useIonViewWillLeave = useIonViewWillLeave;
    exports.withIonLifeCycle = withIonLifeCycle;
  }
});

// dep:@ionic_react-router
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION 1 - HelloWorld/node_modules/@ionic/react-router/dist/index.esm.js
init_define_process_env();
init_tslib_es6();
init_history();
var import_react = __toModule(require_react());
var import_react_router_dom = __toModule(require_react_router_dom2());
var import_react2 = __toModule(require_dist());
init_react_router();
var IonRouteInner = class extends import_react.default.PureComponent {
  render() {
    return import_react.default.createElement(Route, { path: this.props.path, exact: this.props.exact, render: this.props.render, computedMatch: this.props.computedMatch });
  }
};
var ReactRouterViewStack = class extends import_react2.ViewStacks {
  constructor() {
    super();
    this.createViewItem = this.createViewItem.bind(this);
    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);
    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);
    this.getChildrenToRender = this.getChildrenToRender.bind(this);
    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);
  }
  createViewItem(outletId, reactElement, routeInfo, page) {
    const viewItem = {
      id: (0, import_react2.generateId)("viewItem"),
      outletId,
      ionPageElement: page,
      reactElement,
      mount: true,
      ionRoute: false
    };
    const matchProps = {
      exact: reactElement.props.exact,
      path: reactElement.props.path || reactElement.props.from,
      component: reactElement.props.component
    };
    const match = matchPath(routeInfo.pathname, matchProps);
    if (reactElement.type === import_react2.IonRoute) {
      viewItem.ionRoute = true;
      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;
    }
    viewItem.routeData = {
      match,
      childProps: reactElement.props
    };
    return viewItem;
  }
  getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {
    const viewItems = this.getViewItemsForOutlet(outletId);
    import_react.default.Children.forEach(ionRouterOutlet.props.children, (child) => {
      const viewItem = viewItems.find((v) => {
        return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);
      });
      if (viewItem) {
        viewItem.reactElement = child;
      }
    });
    const children = viewItems.map((viewItem) => {
      let clonedChild;
      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {
        clonedChild = import_react.default.createElement(import_react2.ViewLifeCycleManager, { key: `view-${viewItem.id}`, mount: viewItem.mount, removeView: () => this.remove(viewItem) }, import_react.default.cloneElement(viewItem.reactElement, {
          computedMatch: viewItem.routeData.match
        }));
      } else {
        const match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);
        clonedChild = import_react.default.createElement(import_react2.ViewLifeCycleManager, { key: `view-${viewItem.id}`, mount: viewItem.mount, removeView: () => this.remove(viewItem) }, import_react.default.cloneElement(viewItem.reactElement, {
          computedMatch: viewItem.routeData.match
        }));
        if (!match && viewItem.routeData.match) {
          viewItem.routeData.match = void 0;
          viewItem.mount = false;
        }
      }
      return clonedChild;
    });
    return children;
  }
  findViewItemByRouteInfo(routeInfo, outletId) {
    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);
    if (viewItem && match) {
      viewItem.routeData.match = match;
    }
    return viewItem;
  }
  findLeavingViewItemByRouteInfo(routeInfo, outletId, mustBeIonRoute = true) {
    const { viewItem } = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute);
    return viewItem;
  }
  findViewItemByPathname(pathname, outletId) {
    const { viewItem } = this.findViewItemByPath(pathname, outletId);
    return viewItem;
  }
  findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {
    let viewItem;
    let match;
    let viewStack;
    if (outletId) {
      viewStack = this.getViewItemsForOutlet(outletId);
      viewStack.some(matchView);
      if (!viewItem) {
        viewStack.some(matchDefaultRoute);
      }
    } else {
      const viewItems = this.getAllViewItems();
      viewItems.some(matchView);
      if (!viewItem) {
        viewItems.some(matchDefaultRoute);
      }
    }
    return { viewItem, match };
    function matchView(v) {
      if (mustBeIonRoute && !v.ionRoute) {
        return false;
      }
      const matchProps = {
        exact: forceExact ? true : v.routeData.childProps.exact,
        path: v.routeData.childProps.path || v.routeData.childProps.from,
        component: v.routeData.childProps.component
      };
      const myMatch = matchPath(pathname, matchProps);
      if (myMatch) {
        viewItem = v;
        match = myMatch;
        return true;
      }
      return false;
    }
    function matchDefaultRoute(v) {
      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {
        match = {
          path: pathname,
          url: pathname,
          isExact: true,
          params: {}
        };
        viewItem = v;
        return true;
      }
      return false;
    }
  }
};
function matchComponent$1(node, pathname, forceExact) {
  const matchProps = {
    exact: forceExact ? true : node.props.exact,
    path: node.props.path || node.props.from,
    component: node.props.component
  };
  const match = matchPath(pathname, matchProps);
  return match;
}
function clonePageElement(leavingViewHtml) {
  let html;
  if (typeof leavingViewHtml === "string") {
    html = leavingViewHtml;
  } else {
    html = leavingViewHtml.outerHTML;
  }
  if (document) {
    const newEl = document.createElement("div");
    newEl.innerHTML = html;
    newEl.style.zIndex = "";
    const ionBackButton = newEl.getElementsByTagName("ion-back-button");
    if (ionBackButton[0]) {
      ionBackButton[0].remove();
    }
    return newEl.firstChild;
  }
  return void 0;
}
var StackManager = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this.stackContextValue = {
      registerIonPage: this.registerIonPage.bind(this),
      isInOutlet: () => true
    };
    this.registerIonPage = this.registerIonPage.bind(this);
    this.transitionPage = this.transitionPage.bind(this);
    this.handlePageTransition = this.handlePageTransition.bind(this);
    this.id = (0, import_react2.generateId)("routerOutlet");
  }
  componentDidMount() {
    if (this.routerOutletElement) {
      this.setupRouterOutlet(this.routerOutletElement);
      this.handlePageTransition(this.props.routeInfo);
    }
  }
  componentDidUpdate(prevProps) {
    if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname) {
      this.handlePageTransition(this.props.routeInfo);
    }
  }
  componentWillUnmount() {
    this.context.clearOutlet(this.id);
  }
  async handlePageTransition(routeInfo) {
    var _a, _b;
    if (!this.routerOutletElement || !this.routerOutletElement.commit) {
      setTimeout(() => this.handlePageTransition(routeInfo), 10);
    } else {
      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);
      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);
      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {
        leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);
      }
      if (leavingViewItem) {
        if (routeInfo.routeAction === "replace") {
          leavingViewItem.mount = false;
        } else if (!(routeInfo.routeAction === "push" && routeInfo.routeDirection === "forward")) {
          if (routeInfo.routeDirection !== "none" && enteringViewItem !== leavingViewItem) {
            leavingViewItem.mount = false;
          }
        } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {
          leavingViewItem.mount = false;
        }
      }
      const enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);
      if (enteringViewItem) {
        enteringViewItem.reactElement = enteringRoute;
      }
      if (!enteringViewItem) {
        if (enteringRoute) {
          enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);
          this.context.addViewItem(enteringViewItem);
        }
      }
      if (enteringViewItem && enteringViewItem.ionPageElement) {
        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);
      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {
        if (leavingViewItem.ionPageElement) {
          leavingViewItem.ionPageElement.classList.add("ion-page-hidden");
          leavingViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        }
      }
      this.forceUpdate();
    }
  }
  registerIonPage(page, routeInfo) {
    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);
    if (foundView) {
      foundView.ionPageElement = page;
      foundView.ionRoute = true;
    }
    this.handlePageTransition(routeInfo);
  }
  async setupRouterOutlet(routerOutlet) {
    const canStart = () => {
      const config = (0, import_react2.getConfig)();
      const swipeEnabled = config && config.get("swipeBackEnabled", routerOutlet.mode === "ios");
      if (swipeEnabled) {
        return this.context.canGoBack();
      } else {
        return false;
      }
    };
    const onStart = () => {
      this.context.goBack();
    };
    routerOutlet.swipeHandler = {
      canStart,
      onStart,
      onEnd: (_shouldContinue) => true
    };
  }
  async transitionPage(routeInfo, enteringViewItem, leavingViewItem) {
    const routerOutlet = this.routerOutletElement;
    const direction = routeInfo.routeDirection === "none" || routeInfo.routeDirection === "root" ? void 0 : routeInfo.routeDirection;
    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {
      if (leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem) {
        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);
        if (match) {
          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);
          if (newLeavingElement) {
            this.routerOutletElement.appendChild(newLeavingElement);
            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);
            this.routerOutletElement.removeChild(newLeavingElement);
          }
        } else {
          await runCommit(enteringViewItem.ionPageElement, void 0);
        }
      } else {
        await runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);
        if (leavingViewItem && leavingViewItem.ionPageElement) {
          leavingViewItem.ionPageElement.classList.add("ion-page-hidden");
          leavingViewItem.ionPageElement.setAttribute("aria-hidden", "true");
        }
      }
    }
    async function runCommit(enteringEl, leavingEl) {
      enteringEl.classList.add("ion-page");
      enteringEl.classList.add("ion-page-invisible");
      await routerOutlet.commit(enteringEl, leavingEl, {
        deepWait: true,
        duration: direction === void 0 ? 0 : void 0,
        direction,
        showGoBack: !!routeInfo.pushedByRoute,
        progressAnimation: false,
        animationBuilder: routeInfo.routeAnimation
      });
    }
  }
  render() {
    const { children } = this.props;
    const ionRouterOutlet = import_react.default.Children.only(children);
    this.ionRouterOutlet = ionRouterOutlet;
    const components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, () => {
      this.forceUpdate();
    });
    return import_react.default.createElement(import_react2.StackContext.Provider, { value: this.stackContextValue }, import_react.default.cloneElement(ionRouterOutlet, {
      ref: (node) => {
        if (ionRouterOutlet.props.setRef) {
          ionRouterOutlet.props.setRef(node);
        }
        if (ionRouterOutlet.props.forwardedRef) {
          ionRouterOutlet.props.forwardedRef.current = node;
        }
        this.routerOutletElement = node;
        const { ref } = ionRouterOutlet;
        if (typeof ref === "function") {
          ref(node);
        }
      }
    }, components));
  }
  static get contextType() {
    return import_react2.RouteManagerContext;
  }
};
function matchRoute(node, routeInfo) {
  let matchedNode;
  import_react.default.Children.forEach(node, (child) => {
    const matchProps = {
      exact: child.props.exact,
      path: child.props.path || child.props.from,
      component: child.props.component
    };
    const match = (0, import_react_router_dom.matchPath)(routeInfo.pathname, matchProps);
    if (match) {
      matchedNode = child;
    }
  });
  if (matchedNode) {
    return matchedNode;
  }
  import_react.default.Children.forEach(node, (child) => {
    if (!(child.props.path || child.props.from)) {
      matchedNode = child;
    }
  });
  return matchedNode;
}
function matchComponent(node, pathname, forceExact) {
  const matchProps = {
    exact: forceExact ? true : node.props.exact,
    path: node.props.path || node.props.from,
    component: node.props.component
  };
  const match = (0, import_react_router_dom.matchPath)(pathname, matchProps);
  return match;
}
var IonRouterInner = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this.exitViewFromOtherOutletHandlers = [];
    this.locationHistory = new import_react2.LocationHistory();
    this.viewStack = new ReactRouterViewStack();
    this.routeMangerContextState = {
      canGoBack: () => this.locationHistory.canGoBack(),
      clearOutlet: this.viewStack.clear,
      findViewItemByPathname: this.viewStack.findViewItemByPathname,
      getChildrenToRender: this.viewStack.getChildrenToRender,
      goBack: () => this.handleNavigateBack(),
      createViewItem: this.viewStack.createViewItem,
      findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,
      findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,
      addViewItem: this.viewStack.add,
      unMountViewItem: this.viewStack.remove
    };
    const routeInfo = {
      id: (0, import_react2.generateId)("routeInfo"),
      pathname: this.props.location.pathname,
      search: this.props.location.search
    };
    this.locationHistory.add(routeInfo);
    this.handleChangeTab = this.handleChangeTab.bind(this);
    this.handleResetTab = this.handleResetTab.bind(this);
    this.handleNativeBack = this.handleNativeBack.bind(this);
    this.handleNavigate = this.handleNavigate.bind(this);
    this.handleNavigateBack = this.handleNavigateBack.bind(this);
    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));
    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);
    this.state = {
      routeInfo
    };
  }
  handleChangeTab(tab, path, routeOptions) {
    if (!path) {
      return;
    }
    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);
    const [pathname, search] = path.split("?");
    if (routeInfo) {
      this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), { routeAction: "push", routeDirection: "none" });
      if (routeInfo.pathname === pathname) {
        this.incomingRouteParams.routeOptions = routeOptions;
        this.props.history.push(routeInfo.pathname + (routeInfo.search || ""));
      } else {
        this.incomingRouteParams.pathname = pathname;
        this.incomingRouteParams.search = search ? "?" + search : void 0;
        this.incomingRouteParams.routeOptions = routeOptions;
        this.props.history.push(pathname + (search ? "?" + search : ""));
      }
    } else {
      this.handleNavigate(pathname, "push", "none", void 0, routeOptions, tab);
    }
  }
  handleHistoryChange(location, action) {
    var _a, _b, _c;
    let leavingLocationInfo;
    if (this.incomingRouteParams) {
      if (this.incomingRouteParams.routeAction === "replace") {
        leavingLocationInfo = this.locationHistory.previous();
      } else {
        leavingLocationInfo = this.locationHistory.current();
      }
    } else {
      leavingLocationInfo = this.locationHistory.current();
    }
    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;
    if (leavingUrl !== location.pathname) {
      if (!this.incomingRouteParams) {
        if (action === "REPLACE") {
          this.incomingRouteParams = {
            routeAction: "replace",
            routeDirection: "none",
            tab: this.currentTab
          };
        }
        if (action === "POP") {
          const currentRoute = this.locationHistory.current();
          if (currentRoute && currentRoute.pushedByRoute) {
            const prevInfo = this.locationHistory.findLastLocation(currentRoute);
            this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: "pop", routeDirection: "back" });
          } else {
            this.incomingRouteParams = {
              routeAction: "pop",
              routeDirection: "none",
              tab: this.currentTab
            };
          }
        }
        if (!this.incomingRouteParams) {
          this.incomingRouteParams = {
            routeAction: "push",
            routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || "forward",
            routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,
            tab: this.currentTab
          };
        }
      }
      let routeInfo;
      if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {
        routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });
        this.locationHistory.add(routeInfo);
      } else {
        const isPushed = this.incomingRouteParams.routeAction === "push" && this.incomingRouteParams.routeDirection === "forward";
        routeInfo = Object.assign(Object.assign({ id: (0, import_react2.generateId)("routeInfo") }, this.incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.pathname, search: location.search, params: this.props.match.params, prevRouteLastPathname: leavingLocationInfo.lastPathname });
        if (isPushed) {
          routeInfo.tab = leavingLocationInfo.tab;
          routeInfo.pushedByRoute = leavingLocationInfo.pathname;
        } else if (routeInfo.routeAction === "pop") {
          const r = this.locationHistory.findLastLocation(routeInfo);
          routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;
        } else if (routeInfo.routeAction === "push" && routeInfo.tab !== leavingLocationInfo.tab) {
          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);
          routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;
        } else if (routeInfo.routeAction === "replace") {
          const currentRouteInfo = this.locationHistory.current();
          const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;
          const pushedByRoute = currentPushedBy !== void 0 && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;
          routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;
          routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;
          routeInfo.pushedByRoute = pushedByRoute;
          routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;
          routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;
        }
        this.locationHistory.add(routeInfo);
      }
      this.setState({
        routeInfo
      });
    }
    this.incomingRouteParams = void 0;
  }
  handleNativeBack() {
    const history = this.props.history;
    const goBack = history.goBack || history.back;
    goBack();
  }
  handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {
    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {
      routeAction,
      routeDirection,
      routeOptions,
      routeAnimation,
      tab
    });
    if (routeAction === "push") {
      this.props.history.push(path);
    } else {
      this.props.history.replace(path);
    }
  }
  handleNavigateBack(defaultHref = "/", routeAnimation) {
    const config = (0, import_react2.getConfig)();
    defaultHref = defaultHref ? defaultHref : config && config.get("backButtonDefaultHref");
    const routeInfo = this.locationHistory.current();
    if (routeInfo && routeInfo.pushedByRoute) {
      const prevInfo = this.locationHistory.findLastLocation(routeInfo);
      if (prevInfo) {
        this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routeAction: "pop", routeDirection: "back", routeAnimation: routeAnimation || routeInfo.routeAnimation });
        if (routeInfo.lastPathname === routeInfo.pushedByRoute || prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === "" && prevInfo.tab === "") {
          const history = this.props.history;
          const goBack = history.goBack || history.back;
          goBack();
        } else {
          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ""), "pop", "back");
        }
      } else {
        this.handleNavigate(defaultHref, "pop", "back");
      }
    } else {
      this.handleNavigate(defaultHref, "pop", "back");
    }
  }
  handleResetTab(tab, originalHref, originalRouteOptions) {
    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);
    if (routeInfo) {
      const newRouteInfo = Object.assign({}, routeInfo);
      newRouteInfo.pathname = originalHref;
      newRouteInfo.routeOptions = originalRouteOptions;
      this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), { routeAction: "pop", routeDirection: "back" });
      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ""));
    }
  }
  handleSetCurrentTab(tab) {
    this.currentTab = tab;
    const ri = Object.assign({}, this.locationHistory.current());
    if (ri.tab !== tab) {
      ri.tab = tab;
      this.locationHistory.update(ri);
    }
  }
  render() {
    return import_react.default.createElement(import_react2.RouteManagerContext.Provider, { value: this.routeMangerContextState }, import_react.default.createElement(import_react2.NavManager, { ionRoute: IonRouteInner, ionRedirect: {}, stackManager: StackManager, routeInfo: this.state.routeInfo, onNativeBack: this.handleNativeBack, onNavigateBack: this.handleNavigateBack, onNavigate: this.handleNavigate, onSetCurrentTab: this.handleSetCurrentTab, onChangeTab: this.handleChangeTab, onResetTab: this.handleResetTab, locationHistory: this.locationHistory }, this.props.children));
  }
};
var IonRouter = (0, import_react_router_dom.withRouter)(IonRouterInner);
IonRouter.displayName = "IonRouter";
var IonReactRouter = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    const { history } = props, rest = __rest(props, ["history"]);
    this.history = history || createBrowserHistory(rest);
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb) {
    this.historyListenHandler = cb;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return import_react.default.createElement(import_react_router_dom.Router, Object.assign({ history: this.history }, props), import_react.default.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children));
  }
};
var IonReactMemoryRouter = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.history = props.history;
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb) {
    this.historyListenHandler = cb;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return import_react.default.createElement(Router, Object.assign({}, props), import_react.default.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children));
  }
};
var IonReactHashRouter = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    const { history } = props, rest = __rest(props, ["history"]);
    this.history = history || createHashHistory(rest);
    this.history.listen(this.handleHistoryChange.bind(this));
    this.registerHistoryListener = this.registerHistoryListener.bind(this);
  }
  handleHistoryChange(location, action) {
    const locationValue = location.location || location;
    const actionValue = location.action || action;
    if (this.historyListenHandler) {
      this.historyListenHandler(locationValue, actionValue);
    }
  }
  registerHistoryListener(cb) {
    this.historyListenHandler = cb;
  }
  render() {
    const _a = this.props, { children } = _a, props = __rest(_a, ["children"]);
    return import_react.default.createElement(import_react_router_dom.Router, Object.assign({ history: this.history }, props), import_react.default.createElement(IonRouter, { registerHistoryListener: this.registerHistoryListener }, children));
  }
};
export {
  IonReactHashRouter,
  IonReactMemoryRouter,
  IonReactRouter
};
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
//# sourceMappingURL=@ionic_react-router.js.map
