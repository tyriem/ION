import {
  IonicSafeString,
  actionSheetController,
  addIcons,
  alertController,
  arrowBackSharp,
  caretBackSharp,
  chevronBack,
  chevronForward,
  close,
  closeCircle,
  closeSharp,
  createGesture,
  defineCustomElements,
  getPlatforms,
  init_dist,
  init_dist2,
  init_icons,
  init_loader,
  isPlatform,
  loadingController,
  menuOutline,
  menuSharp,
  modalController,
  pickerController,
  popoverController,
  reorderThreeOutline,
  reorderTwoSharp,
  searchOutline,
  searchSharp,
  setupConfig,
  toastController
} from "./chunk-F6YEIAHG.js";
import {
  mdTransitionAnimation
} from "./chunk-4674Q6F5.js";
import {
  iosTransitionAnimation
} from "./chunk-JSO227FL.js";
import {
  createAnimation
} from "./chunk-FFQUAV47.js";
import {
  require_react_dom
} from "./chunk-DRKKF5W5.js";
import {
  require_react
} from "./chunk-NZVPNYPO.js";
import {
  __rest,
  init_tslib_es6
} from "./chunk-2TEGCL4A.js";
import {
  __toModule,
  define_process_env_default,
  init_define_process_env
} from "./chunk-ZU54QAZD.js";

// dep:@ionic_react
init_define_process_env();

// ../../../../../Documents/CODE/ION/ION 1 - HelloWorld/node_modules/@ionic/react/dist/index.esm.js
init_define_process_env();
var import_react = __toModule(require_react());
init_loader();
init_dist();
init_icons();
init_dist2();
init_dist2();
init_tslib_es6();
var import_react_dom = __toModule(require_react_dom());
var IonLifeCycleContext = import_react.default.createContext({
  onIonViewWillEnter: () => {
    return;
  },
  ionViewWillEnter: () => {
    return;
  },
  onIonViewDidEnter: () => {
    return;
  },
  ionViewDidEnter: () => {
    return;
  },
  onIonViewWillLeave: () => {
    return;
  },
  ionViewWillLeave: () => {
    return;
  },
  onIonViewDidLeave: () => {
    return;
  },
  ionViewDidLeave: () => {
    return;
  }
});
var DefaultIonLifeCycleContext = class {
  constructor() {
    this.ionViewWillEnterCallbacks = [];
    this.ionViewDidEnterCallbacks = [];
    this.ionViewWillLeaveCallbacks = [];
    this.ionViewDidLeaveCallbacks = [];
  }
  onIonViewWillEnter(callback) {
    if (callback.id) {
      const index = this.ionViewWillEnterCallbacks.findIndex((x) => x.id === callback.id);
      if (index > -1) {
        this.ionViewWillEnterCallbacks[index] = callback;
      } else {
        this.ionViewWillEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewWillEnterCallbacks.push(callback);
    }
  }
  ionViewWillEnter() {
    this.ionViewWillEnterCallbacks.forEach((cb) => cb());
  }
  onIonViewDidEnter(callback) {
    if (callback.id) {
      const index = this.ionViewDidEnterCallbacks.findIndex((x) => x.id === callback.id);
      if (index > -1) {
        this.ionViewDidEnterCallbacks[index] = callback;
      } else {
        this.ionViewDidEnterCallbacks.push(callback);
      }
    } else {
      this.ionViewDidEnterCallbacks.push(callback);
    }
  }
  ionViewDidEnter() {
    this.ionViewDidEnterCallbacks.forEach((cb) => cb());
  }
  onIonViewWillLeave(callback) {
    if (callback.id) {
      const index = this.ionViewWillLeaveCallbacks.findIndex((x) => x.id === callback.id);
      if (index > -1) {
        this.ionViewWillLeaveCallbacks[index] = callback;
      } else {
        this.ionViewWillLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewWillLeaveCallbacks.push(callback);
    }
  }
  ionViewWillLeave() {
    this.ionViewWillLeaveCallbacks.forEach((cb) => cb());
  }
  onIonViewDidLeave(callback) {
    if (callback.id) {
      const index = this.ionViewDidLeaveCallbacks.findIndex((x) => x.id === callback.id);
      if (index > -1) {
        this.ionViewDidLeaveCallbacks[index] = callback;
      } else {
        this.ionViewDidLeaveCallbacks.push(callback);
      }
    } else {
      this.ionViewDidLeaveCallbacks.push(callback);
    }
  }
  ionViewDidLeave() {
    this.ionViewDidLeaveCallbacks.forEach((cb) => cb());
    this.componentCanBeDestroyed();
  }
  onComponentCanBeDestroyed(callback) {
    this.componentCanBeDestroyedCallback = callback;
  }
  componentCanBeDestroyed() {
    if (this.componentCanBeDestroyedCallback) {
      this.componentCanBeDestroyedCallback();
    }
  }
};
var withIonLifeCycle = (WrappedComponent) => {
  return class IonLifeCycle extends import_react.default.Component {
    constructor(props) {
      super(props);
      this.componentRef = import_react.default.createRef();
    }
    componentDidMount() {
      const element = this.componentRef.current;
      this.context.onIonViewWillEnter(() => {
        if (element && element.ionViewWillEnter) {
          element.ionViewWillEnter();
        }
      });
      this.context.onIonViewDidEnter(() => {
        if (element && element.ionViewDidEnter) {
          element.ionViewDidEnter();
        }
      });
      this.context.onIonViewWillLeave(() => {
        if (element && element.ionViewWillLeave) {
          element.ionViewWillLeave();
        }
      });
      this.context.onIonViewDidLeave(() => {
        if (element && element.ionViewDidLeave) {
          element.ionViewDidLeave();
        }
      });
    }
    render() {
      return import_react.default.createElement(IonLifeCycleContext.Consumer, null, (context) => {
        this.context = context;
        return import_react.default.createElement(WrappedComponent, Object.assign({ ref: this.componentRef }, this.props));
      });
    }
  };
};
var useIonViewWillEnter = (callback, deps = []) => {
  const context = (0, import_react.useContext)(IonLifeCycleContext);
  const id = (0, import_react.useRef)();
  id.current = id.current || Math.floor(Math.random() * 1e6);
  (0, import_react.useEffect)(() => {
    callback.id = id.current;
    context.onIonViewWillEnter(callback);
  }, deps);
};
var useIonViewDidEnter = (callback, deps = []) => {
  const context = (0, import_react.useContext)(IonLifeCycleContext);
  const id = (0, import_react.useRef)();
  id.current = id.current || Math.floor(Math.random() * 1e6);
  (0, import_react.useEffect)(() => {
    callback.id = id.current;
    context.onIonViewDidEnter(callback);
  }, deps);
};
var useIonViewWillLeave = (callback, deps = []) => {
  const context = (0, import_react.useContext)(IonLifeCycleContext);
  const id = (0, import_react.useRef)();
  id.current = id.current || Math.floor(Math.random() * 1e6);
  (0, import_react.useEffect)(() => {
    callback.id = id.current;
    context.onIonViewWillLeave(callback);
  }, deps);
};
var useIonViewDidLeave = (callback, deps = []) => {
  const context = (0, import_react.useContext)(IonLifeCycleContext);
  const id = (0, import_react.useRef)();
  id.current = id.current || Math.floor(Math.random() * 1e6);
  (0, import_react.useEffect)(() => {
    callback.id = id.current;
    context.onIonViewDidLeave(callback);
  }, deps);
};
var NavContext = import_react.default.createContext({
  getIonRedirect: () => void 0,
  getIonRoute: () => void 0,
  getPageManager: () => void 0,
  getStackManager: () => void 0,
  goBack: (route) => {
    if (typeof window !== "undefined") {
      if (typeof route === "string") {
        window.location.pathname = route;
      } else {
        window.history.back();
      }
    }
  },
  navigate: (path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  },
  hasIonicRouter: () => false,
  routeInfo: void 0,
  setCurrentTab: () => void 0,
  changeTab: (_tab, path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  },
  resetTab: (_tab, path) => {
    if (typeof window !== "undefined") {
      window.location.pathname = path;
    }
  }
});
var dashToPascalCase = (str) => str.toLowerCase().split("-").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1)).join("");
var camelToDashCase = (str) => str.replace(/([A-Z])/g, (m) => `-${m[0].toLowerCase()}`);
var attachProps = (node, newProps, oldProps = {}) => {
  if (node instanceof Element) {
    const className = getClassName(node.classList, newProps, oldProps);
    if (className !== "") {
      node.className = className;
    }
    Object.keys(newProps).forEach((name) => {
      if (name === "children" || name === "style" || name === "ref" || name === "class" || name === "className" || name === "forwardedRef") {
        return;
      }
      if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
        const eventName = name.substring(2);
        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);
        if (!isCoveredByReact(eventNameLc)) {
          syncEvent(node, eventNameLc, newProps[name]);
        }
      } else {
        const propType = typeof newProps[name];
        if (propType === "string") {
          node.setAttribute(camelToDashCase(name), newProps[name]);
        } else {
          node[name] = newProps[name];
        }
      }
    });
  }
};
var getClassName = (classList, newProps, oldProps) => {
  const newClassProp = newProps.className || newProps.class;
  const oldClassProp = oldProps.className || oldProps.class;
  const currentClasses = arrayToMap(classList);
  const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(" ") : []);
  const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(" ") : []);
  const finalClassNames = [];
  currentClasses.forEach((currentClass) => {
    if (incomingPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
      incomingPropClasses.delete(currentClass);
    } else if (!oldPropClasses.has(currentClass)) {
      finalClassNames.push(currentClass);
    }
  });
  incomingPropClasses.forEach((s) => finalClassNames.push(s));
  return finalClassNames.join(" ");
};
var isCoveredByReact = (eventNameSuffix) => {
  if (typeof document === "undefined") {
    return true;
  } else {
    const eventName = "on" + eventNameSuffix;
    let isSupported = eventName in document;
    if (!isSupported) {
      const element = document.createElement("div");
      element.setAttribute(eventName, "return;");
      isSupported = typeof element[eventName] === "function";
    }
    return isSupported;
  }
};
var syncEvent = (node, eventName, newEventHandler) => {
  const eventStore = node.__events || (node.__events = {});
  const oldEventHandler = eventStore[eventName];
  if (oldEventHandler) {
    node.removeEventListener(eventName, oldEventHandler);
  }
  node.addEventListener(eventName, eventStore[eventName] = function handler(e) {
    if (newEventHandler) {
      newEventHandler.call(this, e);
    }
  });
};
var arrayToMap = (arr) => {
  const map = new Map();
  arr.forEach((s) => map.set(s, s));
  return map;
};
var createForwardRef = (ReactComponent, displayName) => {
  const forwardRef = (props, ref) => {
    return import_react.default.createElement(ReactComponent, Object.assign({}, props, { forwardedRef: ref }));
  };
  forwardRef.displayName = displayName;
  return import_react.default.forwardRef(forwardRef);
};
var setRef = (ref, value) => {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref != null) {
    ref.current = value;
  }
};
var mergeRefs = (...refs) => {
  return (value) => {
    refs.forEach((ref) => {
      setRef(ref, value);
    });
  };
};
var isPlatform2 = (platform) => {
  return isPlatform(window, platform);
};
var getPlatforms2 = () => {
  return getPlatforms(window);
};
var getConfig = () => {
  if (typeof window !== "undefined") {
    const Ionic = window.Ionic;
    if (Ionic && Ionic.config) {
      return Ionic.config;
    }
  }
  return null;
};
var createReactComponent = (tagName, routerLinkComponent = false) => {
  const displayName = dashToPascalCase(tagName);
  const ReactComponent = class extends import_react.default.Component {
    constructor(props) {
      super(props);
      this.handleClick = (e) => {
        const { routerLink, routerDirection, routerOptions, routerAnimation } = this.props;
        if (routerLink !== void 0) {
          e.preventDefault();
          this.context.navigate(routerLink, routerDirection, void 0, routerAnimation, routerOptions);
        }
      };
      this.ref = import_react.default.createRef();
      this.stableMergedRefs = mergeRefs(this.ref, this.props.forwardedRef);
    }
    componentDidMount() {
      this.componentDidUpdate(this.props);
    }
    componentDidUpdate(prevProps) {
      const node = this.ref.current;
      attachProps(node, this.props, prevProps);
    }
    render() {
      const _a = this.props, { children, forwardedRef, style, className, ref } = _a, cProps = __rest(_a, ["children", "forwardedRef", "style", "className", "ref"]);
      const propsToPass = Object.keys(cProps).reduce((acc, name) => {
        if (name.indexOf("on") === 0 && name[2] === name[2].toUpperCase()) {
          const eventName = name.substring(2).toLowerCase();
          if (isCoveredByReact(eventName)) {
            acc[name] = cProps[name];
          }
        } else if (["string", "boolean", "number"].includes(typeof cProps[name])) {
          acc[camelToDashCase(name)] = cProps[name];
        }
        return acc;
      }, {});
      const newProps = Object.assign(Object.assign({}, propsToPass), { ref: this.stableMergedRefs, style });
      if (routerLinkComponent) {
        if (this.props.routerLink && !this.props.href) {
          newProps.href = this.props.routerLink;
        }
        if (newProps.onClick) {
          const oldClick = newProps.onClick;
          newProps.onClick = (e) => {
            oldClick(e);
            if (!e.defaultPrevented) {
              this.handleClick(e);
            }
          };
        } else {
          newProps.onClick = this.handleClick;
        }
      }
      return import_react.default.createElement(tagName, newProps, children);
    }
    static get displayName() {
      return displayName;
    }
    static get contextType() {
      return NavContext;
    }
  };
  return createForwardRef(ReactComponent, displayName);
};
var IonApp = createReactComponent("ion-app");
var IonTab = createReactComponent("ion-tab");
var IonRouterLink = createReactComponent("ion-router-link", true);
var IonAvatar = createReactComponent("ion-avatar");
var IonBackdrop = createReactComponent("ion-backdrop");
var IonBadge = createReactComponent("ion-badge");
var IonButton = createReactComponent("ion-button", true);
var IonButtons = createReactComponent("ion-buttons");
var IonCard = createReactComponent("ion-card", true);
var IonCardContent = createReactComponent("ion-card-content");
var IonCardHeader = createReactComponent("ion-card-header");
var IonCardSubtitle = createReactComponent("ion-card-subtitle");
var IonCardTitle = createReactComponent("ion-card-title");
var IonCheckbox = createReactComponent("ion-checkbox");
var IonCol = createReactComponent("ion-col");
var IonContent = createReactComponent("ion-content");
var IonChip = createReactComponent("ion-chip");
var IonDatetime = createReactComponent("ion-datetime");
var IonFab = createReactComponent("ion-fab");
var IonFabButton = createReactComponent("ion-fab-button", true);
var IonFabList = createReactComponent("ion-fab-list");
var IonFooter = createReactComponent("ion-footer");
var IonGrid = createReactComponent("ion-grid");
var IonHeader = createReactComponent("ion-header");
var IonImg = createReactComponent("ion-img");
var IonInfiniteScroll = createReactComponent("ion-infinite-scroll");
var IonInfiniteScrollContent = createReactComponent("ion-infinite-scroll-content");
var IonInput = createReactComponent("ion-input");
var IonItem = createReactComponent("ion-item", true);
var IonItemDivider = createReactComponent("ion-item-divider");
var IonItemGroup = createReactComponent("ion-item-group");
var IonItemOption = createReactComponent("ion-item-option", true);
var IonItemOptions = createReactComponent("ion-item-options");
var IonItemSliding = createReactComponent("ion-item-sliding");
var IonLabel = createReactComponent("ion-label");
var IonList = createReactComponent("ion-list");
var IonListHeader = createReactComponent("ion-list-header");
var IonMenu = createReactComponent("ion-menu");
var IonMenuButton = createReactComponent("ion-menu-button");
var IonMenuToggle = createReactComponent("ion-menu-toggle");
var IonNote = createReactComponent("ion-note");
var IonPickerColumn = createReactComponent("ion-picker-column");
var IonNav = createReactComponent("ion-nav");
var IonProgressBar = createReactComponent("ion-progress-bar");
var IonRadio = createReactComponent("ion-radio");
var IonRadioGroup = createReactComponent("ion-radio-group");
var IonRange = createReactComponent("ion-range");
var IonRefresher = createReactComponent("ion-refresher");
var IonRefresherContent = createReactComponent("ion-refresher-content");
var IonReorder = createReactComponent("ion-reorder");
var IonReorderGroup = createReactComponent("ion-reorder-group");
var IonRippleEffect = createReactComponent("ion-ripple-effect");
var IonRow = createReactComponent("ion-row");
var IonSearchbar = createReactComponent("ion-searchbar");
var IonSegment = createReactComponent("ion-segment");
var IonSegmentButton = createReactComponent("ion-segment-button");
var IonSelect = createReactComponent("ion-select");
var IonSelectOption = createReactComponent("ion-select-option");
var IonSelectPopover = createReactComponent("ion-select-popover");
var IonSkeletonText = createReactComponent("ion-skeleton-text");
var IonSlide = createReactComponent("ion-slide");
var IonSlides = createReactComponent("ion-slides");
var IonSpinner = createReactComponent("ion-spinner");
var IonSplitPane = createReactComponent("ion-split-pane");
var IonText = createReactComponent("ion-text");
var IonTextarea = createReactComponent("ion-textarea");
var IonThumbnail = createReactComponent("ion-thumbnail");
var IonTitle = createReactComponent("ion-title");
var IonToggle = createReactComponent("ion-toggle");
var IonToolbar = createReactComponent("ion-toolbar");
var IonVirtualScroll = createReactComponent("ion-virtual-scroll");
var createControllerComponent = (displayName, controller) => {
  const didDismissEventName = `on${displayName}DidDismiss`;
  const didPresentEventName = `on${displayName}DidPresent`;
  const willDismissEventName = `on${displayName}WillDismiss`;
  const willPresentEventName = `on${displayName}WillPresent`;
  class Overlay extends import_react.default.Component {
    constructor(props) {
      super(props);
      this.isUnmounted = false;
      this.handleDismiss = this.handleDismiss.bind(this);
    }
    static get displayName() {
      return displayName;
    }
    async componentDidMount() {
      const { isOpen } = this.props;
      if (isOpen) {
        this.present();
      }
    }
    componentWillUnmount() {
      this.isUnmounted = true;
      if (this.overlay) {
        this.overlay.dismiss();
      }
    }
    async componentDidUpdate(prevProps) {
      if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
        this.present(prevProps);
      }
      if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
        await this.overlay.dismiss();
      }
    }
    handleDismiss(event) {
      if (this.props.onDidDismiss) {
        this.props.onDidDismiss(event);
      }
      setRef(this.props.forwardedRef, null);
    }
    async present(prevProps) {
      const _a = this.props, cProps = __rest(_a, ["isOpen", "onDidDismiss", "onDidPresent", "onWillDismiss", "onWillPresent"]);
      this.overlay = await controller.create(Object.assign({}, cProps));
      attachProps(this.overlay, {
        [didDismissEventName]: this.handleDismiss,
        [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e),
        [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e),
        [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e)
      }, prevProps);
      if (this.props.isOpen === true && this.isUnmounted === false) {
        setRef(this.props.forwardedRef, this.overlay);
        await this.overlay.present();
      }
    }
    render() {
      return null;
    }
  }
  return import_react.default.forwardRef((props, ref) => {
    return import_react.default.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));
  });
};
var IonAlert = createControllerComponent("IonAlert", alertController);
var IonLoading = createControllerComponent("IonLoading", loadingController);
var toastController2 = {
  create: (options) => toastController.create(options),
  dismiss: (data, role, id) => toastController.dismiss(data, role, id),
  getTop: () => toastController.getTop()
};
var IonToast = createControllerComponent("IonToast", toastController2);
var IonPicker = createControllerComponent("IonPicker", pickerController);
var createOverlayComponent = (displayName, controller) => {
  const didDismissEventName = `on${displayName}DidDismiss`;
  const didPresentEventName = `on${displayName}DidPresent`;
  const willDismissEventName = `on${displayName}WillDismiss`;
  const willPresentEventName = `on${displayName}WillPresent`;
  let isDismissing = false;
  class Overlay extends import_react.default.Component {
    constructor(props) {
      super(props);
      if (typeof document !== "undefined") {
        this.el = document.createElement("div");
      }
      this.handleDismiss = this.handleDismiss.bind(this);
    }
    static get displayName() {
      return displayName;
    }
    componentDidMount() {
      if (this.props.isOpen) {
        this.present();
      }
    }
    componentWillUnmount() {
      if (this.overlay) {
        this.overlay.dismiss();
      }
    }
    handleDismiss(event) {
      if (this.props.onDidDismiss) {
        this.props.onDidDismiss(event);
      }
      setRef(this.props.forwardedRef, null);
    }
    shouldComponentUpdate(nextProps) {
      if (this.overlay && nextProps.isOpen !== this.props.isOpen && nextProps.isOpen === false) {
        isDismissing = true;
      }
      return true;
    }
    async componentDidUpdate(prevProps) {
      if (this.overlay) {
        attachProps(this.overlay, this.props, prevProps);
      }
      if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {
        this.present(prevProps);
      }
      if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {
        await this.overlay.dismiss();
        isDismissing = false;
        this.forceUpdate();
      }
    }
    async present(prevProps) {
      const _a = this.props, cProps = __rest(_a, ["children", "isOpen", "onDidDismiss", "onDidPresent", "onWillDismiss", "onWillPresent"]);
      const elementProps = Object.assign(Object.assign({}, cProps), { ref: this.props.forwardedRef, [didDismissEventName]: this.handleDismiss, [didPresentEventName]: (e) => this.props.onDidPresent && this.props.onDidPresent(e), [willDismissEventName]: (e) => this.props.onWillDismiss && this.props.onWillDismiss(e), [willPresentEventName]: (e) => this.props.onWillPresent && this.props.onWillPresent(e) });
      this.overlay = await controller.create(Object.assign(Object.assign({}, elementProps), { component: this.el, componentProps: {} }));
      setRef(this.props.forwardedRef, this.overlay);
      attachProps(this.overlay, elementProps, prevProps);
      await this.overlay.present();
    }
    render() {
      return import_react_dom.default.createPortal(this.props.isOpen || isDismissing ? this.props.children : null, this.el);
    }
  }
  return import_react.default.forwardRef((props, ref) => {
    return import_react.default.createElement(Overlay, Object.assign({}, props, { forwardedRef: ref }));
  });
};
var actionSheetController2 = {
  create: (options) => actionSheetController.create(options),
  dismiss: (data, role, id) => actionSheetController.dismiss(data, role, id),
  getTop: () => actionSheetController.getTop()
};
var IonActionSheet = createOverlayComponent("IonActionSheet", actionSheetController2);
var IonModal = createOverlayComponent("IonModal", modalController);
var IonPopover = createOverlayComponent("IonPopover", popoverController);
var StackContext = import_react.default.createContext({
  registerIonPage: () => void 0,
  isInOutlet: () => false
});
var PageManager = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this.ionPageElementRef = import_react.default.createRef();
    this.stableMergedRefs = mergeRefs(this.ionPageElementRef, this.props.forwardedRef);
  }
  componentDidMount() {
    if (this.ionPageElementRef.current) {
      if (this.context.isInOutlet()) {
        this.ionPageElementRef.current.classList.add("ion-page-invisible");
      }
      this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);
      this.ionPageElementRef.current.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionPageElementRef.current.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  componentWillUnmount() {
    if (this.ionPageElementRef.current) {
      this.ionPageElementRef.current.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionPageElementRef.current.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a = this.props, { className, children, routeInfo, forwardedRef } = _a, props = __rest(_a, ["className", "children", "routeInfo", "forwardedRef"]);
    return import_react.default.createElement(IonLifeCycleContext.Consumer, null, (context) => {
      this.ionLifeCycleContext = context;
      return import_react.default.createElement("div", Object.assign({ className: className ? `${className} ion-page` : `ion-page`, ref: this.stableMergedRefs }, props), children);
    });
  }
  static get contextType() {
    return StackContext;
  }
};
var IonPageInternal = class extends import_react.default.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const _a = this.props, { className, children, forwardedRef } = _a, props = __rest(_a, ["className", "children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? import_react.default.createElement(PageManager, Object.assign({ className: className ? `${className}` : "", routeInfo: this.context.routeInfo, forwardedRef }, props), children) : import_react.default.createElement("div", Object.assign({ className: className ? `ion-page ${className}` : "ion-page", ref: forwardedRef }, props), children);
  }
  static get displayName() {
    return "IonPage";
  }
  static get contextType() {
    return NavContext;
  }
};
var IonPage = createForwardRef(IonPageInternal, "IonPage");
var IonTabsContext = import_react.default.createContext({
  activeTab: void 0,
  selectTab: () => false
});
var IonTabButtonInner = createReactComponent("ion-tab-button");
var IonTabBarInner = createReactComponent("ion-tab-bar");
var IonBackButtonInner = createReactComponent("ion-back-button");
var IonRouterOutletInner = createReactComponent("ion-router-outlet");
var IonIconInner = createReactComponent("ion-icon");
var OutletPageManager = class extends import_react.default.Component {
  constructor(props) {
    super(props);
  }
  componentDidMount() {
    if (this.ionRouterOutlet) {
      setTimeout(() => {
        this.context.registerIonPage(this.ionRouterOutlet, this.props.routeInfo);
      }, 25);
      this.ionRouterOutlet.addEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionRouterOutlet.addEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  componentWillUnmount() {
    if (this.ionRouterOutlet) {
      this.ionRouterOutlet.removeEventListener("ionViewWillEnter", this.ionViewWillEnterHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewDidEnter", this.ionViewDidEnterHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewWillLeave", this.ionViewWillLeaveHandler.bind(this));
      this.ionRouterOutlet.removeEventListener("ionViewDidLeave", this.ionViewDidLeaveHandler.bind(this));
    }
  }
  ionViewWillEnterHandler() {
    this.ionLifeCycleContext.ionViewWillEnter();
  }
  ionViewDidEnterHandler() {
    this.ionLifeCycleContext.ionViewDidEnter();
  }
  ionViewWillLeaveHandler() {
    this.ionLifeCycleContext.ionViewWillLeave();
  }
  ionViewDidLeaveHandler() {
    this.ionLifeCycleContext.ionViewDidLeave();
  }
  render() {
    const _a = this.props, { StackManager, children, routeInfo } = _a, props = __rest(_a, ["StackManager", "children", "routeInfo"]);
    return import_react.default.createElement(IonLifeCycleContext.Consumer, null, (context) => {
      this.ionLifeCycleContext = context;
      return import_react.default.createElement(StackManager, { routeInfo }, import_react.default.createElement(IonRouterOutletInner, Object.assign({ setRef: (val) => this.ionRouterOutlet = val }, props), children));
    });
  }
  static get contextType() {
    return StackContext;
  }
};
var IonRouterOutletContainer = class extends import_react.default.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const StackManager = this.context.getStackManager();
    const _a = this.props, { children, forwardedRef } = _a, props = __rest(_a, ["children", "forwardedRef"]);
    return this.context.hasIonicRouter() ? props.ionPage ? import_react.default.createElement(OutletPageManager, Object.assign({ StackManager, routeInfo: this.context.routeInfo }, props), children) : import_react.default.createElement(StackManager, { routeInfo: this.context.routeInfo }, import_react.default.createElement(IonRouterOutletInner, Object.assign({}, props, { forwardedRef }), children)) : import_react.default.createElement(IonRouterOutletInner, Object.assign({ ref: forwardedRef }, this.props), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
};
var IonRouterOutlet = createForwardRef(IonRouterOutletContainer, "IonRouterOutlet");
var IonTabButton = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.handleIonTabButtonClick = this.handleIonTabButtonClick.bind(this);
  }
  handleIonTabButtonClick() {
    if (this.props.onClick) {
      this.props.onClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          tab: this.props.tab,
          href: this.props.href,
          routeOptions: this.props.routerOptions
        }
      }));
    }
  }
  render() {
    const _a = this.props, rest = __rest(_a, ["onClick"]);
    return import_react.default.createElement(IonTabButtonInner, Object.assign({ onIonTabButtonClick: this.handleIonTabButtonClick }, rest));
  }
  static get displayName() {
    return "IonTabButton";
  }
};
var IonTabBarUnwrapped = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this.setActiveTabOnContext = (_tab) => {
    };
    const tabs = {};
    import_react.default.Children.forEach(props.children, (child) => {
      var _a, _b, _c, _d;
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        tabs[child.props.tab] = {
          originalHref: child.props.href,
          currentHref: child.props.href,
          originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : void 0,
          currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname) ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : void 0
        };
      }
    });
    this.state = {
      tabs
    };
    this.onTabButtonClick = this.onTabButtonClick.bind(this);
    this.renderTabButton = this.renderTabButton.bind(this);
    this.setActiveTabOnContext = this.setActiveTabOnContext.bind(this);
    this.selectTab = this.selectTab.bind(this);
  }
  componentDidMount() {
    const tabs = this.state.tabs;
    const tabKeys = Object.keys(tabs);
    const activeTab = tabKeys.find((key) => {
      const href = tabs[key].originalHref;
      return this.props.routeInfo.pathname.startsWith(href);
    });
    if (activeTab) {
      this.setState({
        activeTab
      });
    }
  }
  componentDidUpdate() {
    if (this.state.activeTab) {
      this.setActiveTabOnContext(this.state.activeTab);
    }
  }
  selectTab(tab) {
    const tabUrl = this.state.tabs[tab];
    if (tabUrl) {
      this.onTabButtonClick(new CustomEvent("ionTabButtonClick", {
        detail: {
          href: tabUrl.currentHref,
          tab,
          selected: tab === this.state.activeTab,
          routeOptions: void 0
        }
      }));
      return true;
    }
    return false;
  }
  static getDerivedStateFromProps(props, state) {
    var _a, _b, _c;
    const tabs = Object.assign({}, state.tabs);
    const tabKeys = Object.keys(state.tabs);
    const activeTab = tabKeys.find((key) => {
      const href = state.tabs[key].originalHref;
      return props.routeInfo.pathname.startsWith(href);
    });
    import_react.default.Children.forEach(props.children, (child) => {
      if (child != null && typeof child === "object" && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const tab = tabs[child.props.tab];
        if (!tab || tab.originalHref !== child.props.href) {
          tabs[child.props.tab] = {
            originalHref: child.props.href,
            currentHref: child.props.href,
            originalRouteOptions: child.props.routeOptions,
            currentRouteOptions: child.props.routeOptions
          };
        }
      }
    });
    const { activeTab: prevActiveTab } = state;
    if (activeTab && prevActiveTab) {
      const prevHref = state.tabs[prevActiveTab].currentHref;
      const prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;
      if (activeTab !== prevActiveTab || prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) || prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {
        tabs[activeTab] = {
          originalHref: tabs[activeTab].originalHref,
          currentHref: props.routeInfo.pathname + (props.routeInfo.search || ""),
          originalRouteOptions: tabs[activeTab].originalRouteOptions,
          currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions
        };
        if (props.routeInfo.routeAction === "pop" && activeTab !== prevActiveTab) {
          tabs[prevActiveTab] = {
            originalHref: tabs[prevActiveTab].originalHref,
            currentHref: tabs[prevActiveTab].originalHref,
            originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,
            currentRouteOptions: tabs[prevActiveTab].currentRouteOptions
          };
        }
      }
    }
    activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);
    return {
      activeTab,
      tabs
    };
  }
  onTabButtonClick(e) {
    const tappedTab = this.state.tabs[e.detail.tab];
    const originalHref = tappedTab.originalHref;
    const currentHref = e.detail.href;
    const { activeTab: prevActiveTab } = this.state;
    if (prevActiveTab === e.detail.tab) {
      if (originalHref !== currentHref) {
        this.context.resetTab(e.detail.tab, originalHref, tappedTab.originalRouteOptions);
      }
    } else {
      if (this.props.onIonTabsWillChange) {
        this.props.onIonTabsWillChange(new CustomEvent("ionTabWillChange", { detail: { tab: e.detail.tab } }));
      }
      if (this.props.onIonTabsDidChange) {
        this.props.onIonTabsDidChange(new CustomEvent("ionTabDidChange", { detail: { tab: e.detail.tab } }));
      }
      this.setActiveTabOnContext(e.detail.tab);
      this.context.changeTab(e.detail.tab, currentHref, e.detail.routeOptions);
    }
  }
  renderTabButton(activeTab) {
    return (child) => {
      var _a, _b;
      if (child != null && child.props && (child.type === IonTabButton || child.type.isTabButton)) {
        const href = child.props.tab === activeTab ? (_a = this.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : this.state.tabs[child.props.tab].currentHref;
        const routeOptions = child.props.tab === activeTab ? (_b = this.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : this.state.tabs[child.props.tab].currentRouteOptions;
        return import_react.default.cloneElement(child, {
          href,
          routeOptions,
          onClick: this.onTabButtonClick
        });
      }
      return null;
    };
  }
  render() {
    const { activeTab } = this.state;
    return import_react.default.createElement(IonTabBarInner, Object.assign({}, this.props, { selectedTab: activeTab }), import_react.default.Children.map(this.props.children, this.renderTabButton(activeTab)));
  }
  static get contextType() {
    return NavContext;
  }
};
var IonTabBarContainer = import_react.default.memo((_a) => {
  var { forwardedRef } = _a, props = __rest(_a, ["forwardedRef"]);
  const context = (0, import_react.useContext)(NavContext);
  return import_react.default.createElement(IonTabBarUnwrapped, Object.assign({ ref: forwardedRef }, props, { routeInfo: props.routeInfo || context.routeInfo || { pathname: window.location.pathname }, onSetCurrentTab: context.setCurrentTab }), props.children);
});
var IonTabBar = createForwardRef(IonTabBarContainer, "IonTabBar");
var IonTabsElement = class extends HTMLElement {
  constructor() {
    super();
  }
};
if (window && window.customElements) {
  const element = customElements.get("ion-tabs");
  if (!element) {
    customElements.define("ion-tabs", IonTabsElement);
  }
}
var hostStyles = {
  display: "flex",
  position: "absolute",
  top: "0",
  left: "0",
  right: "0",
  bottom: "0",
  flexDirection: "column",
  width: "100%",
  height: "100%",
  contain: "layout size style"
};
var tabsInner = {
  position: "relative",
  flex: 1,
  contain: "layout size style"
};
var IonTabs = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.routerOutletRef = import_react.default.createRef();
    this.tabBarRef = import_react.default.createRef();
    this.ionTabContextState = {
      activeTab: void 0,
      selectTab: () => false
    };
  }
  componentDidMount() {
    if (this.tabBarRef.current) {
      this.ionTabContextState.activeTab = this.tabBarRef.current.state.activeTab;
      this.tabBarRef.current.setActiveTabOnContext = (tab) => {
        this.ionTabContextState.activeTab = tab;
      };
      this.ionTabContextState.selectTab = this.tabBarRef.current.selectTab;
    }
  }
  render() {
    let outlet;
    let tabBar;
    const _a = this.props, { className, onIonTabsDidChange, onIonTabsWillChange } = _a, props = __rest(_a, ["className", "onIonTabsDidChange", "onIonTabsWillChange"]);
    const children = typeof this.props.children === "function" ? this.props.children(this.ionTabContextState) : this.props.children;
    import_react.default.Children.forEach(children, (child) => {
      if (child == null || typeof child !== "object" || !child.hasOwnProperty("type")) {
        return;
      }
      if (child.type === IonRouterOutlet || child.type.isRouterOutlet) {
        outlet = import_react.default.cloneElement(child, { tabs: true });
      } else if (child.type === import_react.Fragment && child.props.children[0].type === IonRouterOutlet) {
        outlet = child.props.children[0];
      }
      let childProps = {
        ref: this.tabBarRef
      };
      if (onIonTabsDidChange !== void 0) {
        childProps = Object.assign(Object.assign({}, childProps), { onIonTabsDidChange });
      }
      if (onIonTabsWillChange !== void 0) {
        childProps = Object.assign(Object.assign({}, childProps), { onIonTabsWillChange });
      }
      if (child.type === IonTabBar || child.type.isTabBar) {
        tabBar = import_react.default.cloneElement(child, childProps);
      } else if (child.type === import_react.Fragment && (child.props.children[1].type === IonTabBar || child.props.children[1].type.isTabBar)) {
        tabBar = import_react.default.cloneElement(child.props.children[1], childProps);
      }
    });
    if (!outlet) {
      throw new Error("IonTabs must contain an IonRouterOutlet");
    }
    if (!tabBar) {
      throw new Error("IonTabs needs a IonTabBar");
    }
    return import_react.default.createElement(IonTabsContext.Provider, { value: this.ionTabContextState }, this.context.hasIonicRouter() ? import_react.default.createElement(PageManager, Object.assign({ className: className ? `${className}` : "", routeInfo: this.context.routeInfo }, props), import_react.default.createElement("ion-tabs", { className: "ion-tabs", style: hostStyles }, tabBar.props.slot === "top" ? tabBar : null, import_react.default.createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet), tabBar.props.slot === "bottom" ? tabBar : null)) : import_react.default.createElement("div", Object.assign({ className: className ? `${className}` : "ion-tabs" }, props, { style: hostStyles }), tabBar.props.slot === "top" ? tabBar : null, import_react.default.createElement("div", { style: tabsInner, className: "tabs-inner" }, outlet), tabBar.props.slot === "bottom" ? tabBar : null));
  }
  static get contextType() {
    return NavContext;
  }
};
var IonBackButton = (() => class extends import_react.default.Component {
  constructor() {
    super(...arguments);
    this.clickButton = (e) => {
      const { defaultHref, routerAnimation } = this.props;
      if (this.context.hasIonicRouter()) {
        e.stopPropagation();
        this.context.goBack(defaultHref, routerAnimation);
      } else if (defaultHref !== void 0) {
        window.location.href = defaultHref;
      }
    };
  }
  render() {
    return import_react.default.createElement(IonBackButtonInner, Object.assign({ onClick: this.clickButton }, this.props));
  }
  static get displayName() {
    return "IonBackButton";
  }
  static get contextType() {
    return NavContext;
  }
})();
var isDevMode = () => {
  return process && define_process_env_default && true;
};
var warnings = {};
var deprecationWarning = (key, message) => {
  if (isDevMode()) {
    if (!warnings[key]) {
      console.warn(message);
      warnings[key] = true;
    }
  }
};
var IonIconContainer = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    if (this.props.name) {
      deprecationWarning("icon-name", 'In Ionic React, you import icons from "ionicons/icons" and set the icon you imported to the "icon" property. Setting the "name" property has no effect.');
    }
  }
  render() {
    var _a, _b;
    const _c = this.props, { icon, ios, md } = _c, rest = __rest(_c, ["icon", "ios", "md"]);
    let iconToUse;
    if (ios || md) {
      if (isPlatform2("ios")) {
        iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;
      } else {
        iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;
      }
    } else {
      iconToUse = icon;
    }
    return import_react.default.createElement(IonIconInner, Object.assign({ ref: this.props.forwardedRef, icon: iconToUse }, rest), this.props.children);
  }
  static get contextType() {
    return NavContext;
  }
};
var IonIcon = createForwardRef(IonIconContainer, "IonIcon");
var IonRoute = class extends import_react.default.PureComponent {
  render() {
    const IonRouteInner = this.context.getIonRoute();
    if (!this.context.hasIonicRouter() || !IonRoute) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRoute>");
      return null;
    }
    return import_react.default.createElement(IonRouteInner, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
};
var IonRedirect = class extends import_react.default.PureComponent {
  render() {
    const IonRedirectInner = this.context.getIonRedirect();
    if (!this.context.hasIonicRouter() || !IonRedirect) {
      console.error("You either do not have an Ionic Router package, or your router does not support using <IonRedirect>");
      return null;
    }
    return import_react.default.createElement(IonRedirectInner, Object.assign({}, this.props));
  }
  static get contextType() {
    return NavContext;
  }
};
var IonRouterContext = import_react.default.createContext({
  routeInfo: void 0,
  push: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  back: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  canGoBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  },
  nativeBack: () => {
    throw new Error("An Ionic Router is required for IonRouterContext");
  }
});
function useIonRouter() {
  const context = (0, import_react.useContext)(IonRouterContext);
  return {
    back: context.back,
    push: context.push,
    goBack: context.back,
    canGoBack: context.canGoBack,
    routeInfo: context.routeInfo
  };
}
var CreateAnimation = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this.nodes = new Map();
    this.animation = createAnimation(props.id);
  }
  setupAnimation(props) {
    const animation = this.animation;
    if (this.nodes.size > 0) {
      animation.addElement(Array.from(this.nodes.values()));
    }
    checkConfig(animation, props);
    checkPlayback(animation, props);
  }
  componentDidMount() {
    const props = this.props;
    this.setupAnimation(props);
  }
  componentDidUpdate(prevProps) {
    const animation = this.animation;
    const props = this.props;
    checkConfig(animation, props, prevProps);
    checkProgress(animation, props, prevProps);
    checkPlayback(animation, props, prevProps);
  }
  render() {
    const { children } = this.props;
    return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.Children.map(children, (child, id) => import_react.default.cloneElement(child, { ref: (el) => this.nodes.set(id, el) })));
  }
};
var checkConfig = (animation, currentProps = {}, prevProps = {}) => {
  const reservedProps = [
    "children",
    "progressStart",
    "progressStep",
    "progressEnd",
    "pause",
    "stop",
    "destroy",
    "play",
    "from",
    "to",
    "fromTo",
    "onFinish"
  ];
  for (const key in currentProps) {
    if (currentProps.hasOwnProperty(key) && !reservedProps.includes(key) && currentProps[key] !== prevProps[key]) {
      animation[key](currentProps[key]);
    }
  }
  const fromValues = currentProps.from;
  if (fromValues && fromValues !== prevProps.from) {
    const values = Array.isArray(fromValues) ? fromValues : [fromValues];
    values.forEach((val) => animation.from(val.property, val.value));
  }
  const toValues = currentProps.to;
  if (toValues && toValues !== prevProps.to) {
    const values = Array.isArray(toValues) ? toValues : [toValues];
    values.forEach((val) => animation.to(val.property, val.value));
  }
  const fromToValues = currentProps.fromTo;
  if (fromToValues && fromToValues !== prevProps.fromTo) {
    const values = Array.isArray(fromToValues) ? fromToValues : [fromToValues];
    values.forEach((val) => animation.fromTo(val.property, val.fromValue, val.toValue));
  }
  const onFinishValues = currentProps.onFinish;
  if (onFinishValues && onFinishValues !== prevProps.onFinish) {
    const values = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];
    values.forEach((val) => animation.onFinish(val.callback, val.opts));
  }
};
var checkProgress = (animation, currentProps = {}, prevProps = {}) => {
  var _a, _b, _c, _d, _e;
  const { progressStart, progressStep, progressEnd } = currentProps;
  if (progressStart && (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) || ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {
    animation.progressStart(progressStart.forceLinearEasing, progressStart.step);
  }
  if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {
    animation.progressStep(progressStep.step);
  }
  if (progressEnd && (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) || ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {
    animation.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);
  }
};
var checkPlayback = (animation, currentProps = {}, prevProps = {}) => {
  if (!prevProps.play && currentProps.play) {
    animation.play();
  }
  if (!prevProps.pause && currentProps.pause) {
    animation.pause();
  }
  if (!prevProps.stop && currentProps.stop) {
    animation.stop();
  }
  if (!prevProps.destroy && currentProps.destroy) {
    animation.destroy();
  }
};
function useController(displayName, controller) {
  const overlayRef = (0, import_react.useRef)();
  const didDismissEventName = (0, import_react.useMemo)(() => `on${displayName}DidDismiss`, [displayName]);
  const didPresentEventName = (0, import_react.useMemo)(() => `on${displayName}DidPresent`, [displayName]);
  const willDismissEventName = (0, import_react.useMemo)(() => `on${displayName}WillDismiss`, [displayName]);
  const willPresentEventName = (0, import_react.useMemo)(() => `on${displayName}WillPresent`, [displayName]);
  const present = async (options) => {
    if (overlayRef.current) {
      return;
    }
    const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
    const handleDismiss = (event) => {
      if (onDidDismiss) {
        onDidDismiss(event);
      }
      overlayRef.current = void 0;
    };
    overlayRef.current = await controller.create(Object.assign({}, rest));
    attachProps(overlayRef.current, {
      [didDismissEventName]: handleDismiss,
      [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),
      [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),
      [willPresentEventName]: (e) => onWillPresent && onWillPresent(e)
    });
    overlayRef.current.present();
  };
  const dismiss = async () => {
    overlayRef.current && await overlayRef.current.dismiss();
    overlayRef.current = void 0;
  };
  return {
    present,
    dismiss
  };
}
function useIonActionSheet() {
  const controller = useController("IonActionSheet", actionSheetController);
  function present(buttonsOrOptions, header) {
    if (Array.isArray(buttonsOrOptions)) {
      controller.present({
        buttons: buttonsOrOptions,
        header
      });
    } else {
      controller.present(buttonsOrOptions);
    }
  }
  return [
    present,
    controller.dismiss
  ];
}
function useIonAlert() {
  const controller = useController("IonAlert", alertController);
  function present(messageOrOptions, buttons) {
    if (typeof messageOrOptions === "string") {
      controller.present({
        message: messageOrOptions,
        buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: "Ok" }]
      });
    } else {
      controller.present(messageOrOptions);
    }
  }
  return [
    present,
    controller.dismiss
  ];
}
function useIonToast() {
  const controller = useController("IonToast", toastController);
  function present(messageOrOptions, duration) {
    if (typeof messageOrOptions === "string") {
      controller.present({
        message: messageOrOptions,
        duration
      });
    } else {
      controller.present(messageOrOptions);
    }
  }
  return [
    present,
    controller.dismiss
  ];
}
function useOverlay(displayName, controller, component, componentProps) {
  const overlayRef = (0, import_react.useRef)();
  const containerElRef = (0, import_react.useRef)();
  const didDismissEventName = (0, import_react.useMemo)(() => `on${displayName}DidDismiss`, [displayName]);
  const didPresentEventName = (0, import_react.useMemo)(() => `on${displayName}DidPresent`, [displayName]);
  const willDismissEventName = (0, import_react.useMemo)(() => `on${displayName}WillDismiss`, [displayName]);
  const willPresentEventName = (0, import_react.useMemo)(() => `on${displayName}WillPresent`, [displayName]);
  const [isOpen, setIsOpen] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    if (isOpen && component && containerElRef.current) {
      if (import_react.default.isValidElement(component)) {
        import_react_dom.default.render(component, containerElRef.current);
      } else {
        import_react_dom.default.render(import_react.default.createElement(component, componentProps), containerElRef.current);
      }
    }
  }, [component, containerElRef.current, isOpen, componentProps]);
  const present = async (options) => {
    if (overlayRef.current) {
      return;
    }
    const { onDidDismiss, onWillDismiss, onDidPresent, onWillPresent } = options, rest = __rest(options, ["onDidDismiss", "onWillDismiss", "onDidPresent", "onWillPresent"]);
    if (typeof document !== "undefined") {
      containerElRef.current = document.createElement("div");
    }
    overlayRef.current = await controller.create(Object.assign(Object.assign({}, rest), { component: containerElRef.current }));
    attachProps(overlayRef.current, {
      [didDismissEventName]: handleDismiss,
      [didPresentEventName]: (e) => onDidPresent && onDidPresent(e),
      [willDismissEventName]: (e) => onWillDismiss && onWillDismiss(e),
      [willPresentEventName]: (e) => onWillPresent && onWillPresent(e)
    });
    overlayRef.current.present();
    setIsOpen(true);
    function handleDismiss(event) {
      if (onDidDismiss) {
        onDidDismiss(event);
      }
      overlayRef.current = void 0;
      containerElRef.current = void 0;
      setIsOpen(false);
    }
  };
  const dismiss = async () => {
    overlayRef.current && await overlayRef.current.dismiss();
    overlayRef.current = void 0;
    containerElRef.current = void 0;
  };
  return {
    present,
    dismiss
  };
}
function useIonModal(component, componentProps) {
  const controller = useOverlay("IonModal", modalController, component, componentProps);
  function present(options = {}) {
    controller.present(options);
  }
  return [
    present,
    controller.dismiss
  ];
}
function useIonPopover(component, componentProps) {
  const controller = useOverlay("IonPopover", popoverController, component, componentProps);
  function present(options = {}) {
    controller.present(options);
  }
  return [
    present,
    controller.dismiss
  ];
}
function useIonPicker() {
  const controller = useController("IonPicker", pickerController);
  function present(columnsOrOptions, buttons) {
    if (Array.isArray(columnsOrOptions)) {
      controller.present({
        columns: columnsOrOptions,
        buttons: buttons !== null && buttons !== void 0 ? buttons : [{ text: "Ok" }]
      });
    } else {
      controller.present(columnsOrOptions);
    }
  }
  return [present, controller.dismiss];
}
function useIonLoading() {
  const controller = useController("IonLoading", loadingController);
  function present(messageOrOptions = "", duration, spinner) {
    if (typeof messageOrOptions === "string") {
      controller.present({
        message: messageOrOptions,
        duration,
        spinner: spinner !== null && spinner !== void 0 ? spinner : "lines"
      });
    } else {
      controller.present(messageOrOptions);
    }
  }
  return [present, controller.dismiss];
}
addIcons({
  "arrow-back-sharp": arrowBackSharp,
  "caret-back-sharp": caretBackSharp,
  "chevron-back": chevronBack,
  "chevron-forward": chevronForward,
  close,
  "close-circle": closeCircle,
  "close-sharp": closeSharp,
  "menu-outline": menuOutline,
  "menu-sharp": menuSharp,
  "reorder-two-sharp": reorderTwoSharp,
  "reorder-three-outline": reorderThreeOutline,
  "search-outline": searchOutline,
  "search-sharp": searchSharp
});
if (typeof window !== "undefined") {
  defineCustomElements(window);
}
var RouteManagerContext = import_react.default.createContext({
  addViewItem: () => void 0,
  canGoBack: () => void 0,
  clearOutlet: () => void 0,
  createViewItem: () => void 0,
  findViewItemByPathname: () => void 0,
  findLeavingViewItemByRouteInfo: () => void 0,
  findViewItemByRouteInfo: () => void 0,
  getChildrenToRender: () => void 0,
  goBack: () => void 0,
  unMountViewItem: () => void 0
});
var ViewLifeCycleManager = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.ionLifeCycleContext = new DefaultIonLifeCycleContext();
    this._isMounted = false;
    this.ionLifeCycleContext.onComponentCanBeDestroyed(() => {
      if (!this.props.mount) {
        if (this._isMounted) {
          this.setState({
            show: false
          }, () => this.props.removeView());
        }
      }
    });
    this.state = {
      show: true
    };
  }
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    this._isMounted = false;
  }
  render() {
    const { show } = this.state;
    return import_react.default.createElement(IonLifeCycleContext.Provider, { value: this.ionLifeCycleContext }, show && this.props.children);
  }
};
var LocationHistory = class {
  constructor() {
    this.locationHistory = [];
    this.tabHistory = {};
  }
  add(routeInfo) {
    if (routeInfo.routeAction === "push" || routeInfo.routeAction == null) {
      this._add(routeInfo);
    } else if (routeInfo.routeAction === "pop") {
      this._pop(routeInfo);
    } else if (routeInfo.routeAction === "replace") {
      this._replace(routeInfo);
    }
    if (routeInfo.routeDirection === "root") {
      this._clear();
      this._add(routeInfo);
    }
  }
  clearTabStack(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      routeInfos.forEach((ri) => {
        this.locationHistory = this.locationHistory.filter((x) => x.id !== ri.id);
      });
      this.tabHistory[tab] = [];
    }
  }
  update(routeInfo) {
    const locationIndex = this.locationHistory.findIndex((x) => x.id === routeInfo.id);
    if (locationIndex > -1) {
      this.locationHistory.splice(locationIndex, 1, routeInfo);
    }
    const tabArray = this.tabHistory[routeInfo.tab || ""];
    if (tabArray) {
      const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);
      if (tabIndex > -1) {
        tabArray.splice(tabIndex, 1, routeInfo);
      } else {
        tabArray.push(routeInfo);
      }
    } else if (routeInfo.tab) {
      this.tabHistory[routeInfo.tab] = [routeInfo];
    }
  }
  _add(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {
        routeInfos.pop();
      }
      routeInfos.push(routeInfo);
    }
    this.locationHistory.push(routeInfo);
  }
  _areRoutesEqual(route1, route2) {
    if (!route1 || !route2) {
      return false;
    }
    return route1.pathname === route2.pathname && route1.search === route2.search;
  }
  _pop(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      routeInfos.pop();
      routeInfos.pop();
      routeInfos.push(routeInfo);
    }
    this.locationHistory.pop();
    this.locationHistory.pop();
    this.locationHistory.push(routeInfo);
  }
  _replace(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    routeInfos && routeInfos.pop();
    this.locationHistory.pop();
    this._add(routeInfo);
  }
  _clear() {
    const keys = Object.keys(this.tabHistory);
    keys.forEach((k) => this.tabHistory[k] = []);
    this.locationHistory = [];
  }
  _getRouteInfosByKey(key) {
    let routeInfos;
    if (key) {
      routeInfos = this.tabHistory[key];
      if (!routeInfos) {
        routeInfos = this.tabHistory[key] = [];
      }
    }
    return routeInfos;
  }
  getFirstRouteInfoForTab(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      return routeInfos[0];
    }
    return void 0;
  }
  getCurrentRouteInfoForTab(tab) {
    const routeInfos = this._getRouteInfosByKey(tab);
    if (routeInfos) {
      return routeInfos[routeInfos.length - 1];
    }
    return void 0;
  }
  findLastLocation(routeInfo) {
    const routeInfos = this._getRouteInfosByKey(routeInfo.tab);
    if (routeInfos) {
      for (let i = routeInfos.length - 2; i >= 0; i--) {
        const ri = routeInfos[i];
        if (ri) {
          if (ri.pathname === routeInfo.pushedByRoute) {
            return ri;
          }
        }
      }
    }
    for (let i = this.locationHistory.length - 2; i >= 0; i--) {
      const ri = this.locationHistory[i];
      if (ri) {
        if (ri.pathname === routeInfo.pushedByRoute) {
          return ri;
        }
      }
    }
    return void 0;
  }
  previous() {
    return this.locationHistory[this.locationHistory.length - 2] || this.locationHistory[this.locationHistory.length - 1];
  }
  current() {
    return this.locationHistory[this.locationHistory.length - 1];
  }
  canGoBack() {
    return this.locationHistory.length > 1;
  }
};
var NavManager = class extends import_react.default.PureComponent {
  constructor(props) {
    super(props);
    this._isMounted = false;
    this.ionRouterContextValue = {
      push: (pathname, routerDirection, routeAction, routerOptions, animationBuilder) => {
        this.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);
      },
      back: (animationBuilder) => {
        this.goBack(void 0, animationBuilder);
      },
      canGoBack: () => this.props.locationHistory.canGoBack(),
      nativeBack: () => this.props.onNativeBack(),
      routeInfo: this.props.routeInfo
    };
    this.state = {
      goBack: this.goBack.bind(this),
      hasIonicRouter: () => true,
      navigate: this.navigate.bind(this),
      getIonRedirect: this.getIonRedirect.bind(this),
      getIonRoute: this.getIonRoute.bind(this),
      getStackManager: this.getStackManager.bind(this),
      getPageManager: this.getPageManager.bind(this),
      routeInfo: this.props.routeInfo,
      setCurrentTab: this.props.onSetCurrentTab,
      changeTab: this.props.onChangeTab,
      resetTab: this.props.onResetTab
    };
    if (typeof document !== "undefined") {
      this.handleHardwareBackButton = this.handleHardwareBackButton.bind(this);
      document.addEventListener("ionBackButton", this.handleHardwareBackButton);
    }
  }
  componentDidMount() {
    this._isMounted = true;
  }
  componentWillUnmount() {
    if (typeof document !== "undefined") {
      document.removeEventListener("ionBackButton", this.handleHardwareBackButton);
      this._isMounted = false;
    }
  }
  handleHardwareBackButton(e) {
    e.detail.register(0, (processNextHandler) => {
      if (this._isMounted) {
        this.nativeGoBack();
        processNextHandler();
      }
    });
  }
  goBack(route, animationBuilder) {
    this.props.onNavigateBack(route, animationBuilder);
  }
  nativeGoBack() {
    this.props.onNativeBack();
  }
  navigate(path, direction = "forward", action = "push", animationBuilder, options, tab) {
    this.props.onNavigate(path, action, direction, animationBuilder, options, tab);
  }
  getPageManager() {
    return PageManager;
  }
  getIonRedirect() {
    return this.props.ionRedirect;
  }
  getIonRoute() {
    return this.props.ionRoute;
  }
  getStackManager() {
    return this.props.stackManager;
  }
  render() {
    return import_react.default.createElement(NavContext.Provider, { value: Object.assign(Object.assign({}, this.state), { routeInfo: this.props.routeInfo }) }, import_react.default.createElement(IonRouterContext.Provider, { value: Object.assign(Object.assign({}, this.ionRouterContextValue), { routeInfo: this.props.routeInfo }) }, this.props.children));
  }
};
var ViewStacks = class {
  constructor() {
    this.viewStacks = {};
    this.add = this.add.bind(this);
    this.clear = this.clear.bind(this);
    this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);
    this.remove = this.remove.bind(this);
  }
  add(viewItem) {
    const { outletId } = viewItem;
    if (!this.viewStacks[outletId]) {
      this.viewStacks[outletId] = [viewItem];
    } else {
      this.viewStacks[outletId].push(viewItem);
    }
  }
  clear(outletId) {
    setTimeout(() => {
      delete this.viewStacks[outletId];
    }, 500);
  }
  getViewItemsForOutlet(outletId) {
    return this.viewStacks[outletId] || [];
  }
  remove(viewItem) {
    const { outletId } = viewItem;
    const viewStack = this.viewStacks[outletId];
    if (viewStack) {
      const viewItemToRemove = viewStack.find((x) => x.id === viewItem.id);
      if (viewItemToRemove) {
        viewItemToRemove.mount = false;
        this.viewStacks[outletId] = viewStack.filter((x) => x.id !== viewItemToRemove.id);
      }
    }
  }
  getStackIds() {
    return Object.keys(this.viewStacks);
  }
  getAllViewItems() {
    const keys = this.getStackIds();
    const viewItems = [];
    keys.forEach((k) => {
      viewItems.push(...this.viewStacks[k]);
    });
    return viewItems;
  }
};
var ids = { main: 0 };
var generateId = (type = "main") => {
  var _a;
  const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;
  ids[type] = id;
  return id.toString();
};
export {
  CreateAnimation,
  DefaultIonLifeCycleContext,
  IonActionSheet,
  IonAlert,
  IonApp,
  IonAvatar,
  IonBackButton,
  IonBackdrop,
  IonBadge,
  IonButton,
  IonButtons,
  IonCard,
  IonCardContent,
  IonCardHeader,
  IonCardSubtitle,
  IonCardTitle,
  IonCheckbox,
  IonChip,
  IonCol,
  IonContent,
  IonDatetime,
  IonFab,
  IonFabButton,
  IonFabList,
  IonFooter,
  IonGrid,
  IonHeader,
  IonIcon,
  IonImg,
  IonInfiniteScroll,
  IonInfiniteScrollContent,
  IonInput,
  IonItem,
  IonItemDivider,
  IonItemGroup,
  IonItemOption,
  IonItemOptions,
  IonItemSliding,
  IonLabel,
  IonLifeCycleContext,
  IonList,
  IonListHeader,
  IonLoading,
  IonMenu,
  IonMenuButton,
  IonMenuToggle,
  IonModal,
  IonNav,
  IonNote,
  IonPage,
  IonPicker,
  IonPickerColumn,
  IonPopover,
  IonProgressBar,
  IonRadio,
  IonRadioGroup,
  IonRange,
  IonRedirect,
  IonRefresher,
  IonRefresherContent,
  IonReorder,
  IonReorderGroup,
  IonRippleEffect,
  IonRoute,
  IonRouterContext,
  IonRouterLink,
  IonRouterOutlet,
  IonRow,
  IonSearchbar,
  IonSegment,
  IonSegmentButton,
  IonSelect,
  IonSelectOption,
  IonSelectPopover,
  IonSkeletonText,
  IonSlide,
  IonSlides,
  IonSpinner,
  IonSplitPane,
  IonTab,
  IonTabBar,
  IonTabButton,
  IonTabs,
  IonTabsContext,
  IonText,
  IonTextarea,
  IonThumbnail,
  IonTitle,
  IonToast,
  IonToggle,
  IonToolbar,
  IonVirtualScroll,
  IonicSafeString,
  LocationHistory,
  NavContext,
  NavManager,
  RouteManagerContext,
  StackContext,
  ViewLifeCycleManager,
  ViewStacks,
  createAnimation,
  createGesture,
  generateId,
  getConfig,
  getPlatforms2 as getPlatforms,
  iosTransitionAnimation,
  isPlatform2 as isPlatform,
  mdTransitionAnimation,
  setupConfig,
  useIonActionSheet,
  useIonAlert,
  useIonLoading,
  useIonModal,
  useIonPicker,
  useIonPopover,
  useIonRouter,
  useIonToast,
  useIonViewDidEnter,
  useIonViewDidLeave,
  useIonViewWillEnter,
  useIonViewWillLeave,
  withIonLifeCycle
};
/**
 * Checks if an event is supported in the current execution environment.
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
//# sourceMappingURL=@ionic_react.js.map
